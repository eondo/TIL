# SW 문제 해결 역량
- SW 문제 해결 역량이란 무엇인가를 이해하고 역량을 강화하는 방법을 히해한다
- 시간복잡도
- 프로그램의 작성하기 위한 기본 중 표준 입출력 방법에 대해 이해하기
- 비트 수준의 연산과 알고리즘에 대해 이해하기
- 컴퓨터에서의 실수 표현 방법에 대해 이해하기

### 문제 해결 능력을 훈련하기 위해서
- 경험을 통해서 나아지리라 막연히 짐작만 하는데 경험에서는 문제 해결 능력을 개발할 수 있는 상황이 항상 주어지는 것이 아니며 그런 상황에서 자기 개발을 하기 쉽지 않음 → 잘 정제된 추상적인 문제를 제시하고 이를 해결해가면서 문제 해결 능력을 향상시킬 수 있는 훈련이 필요

- 문제 해결 전략
  - 직관과 체계적인 접근
    - 비슷한 문제를 풀어본 적이 있던가?
    - 단순한 방법에서 시작할 수 있을까?
    - 문제를 단순화할 수 있을까?
    - 그림으로 그려 볼 수 있을까?
    - 수식으로 표현 할 수 있을까?
    - 문제를 분해할 수 있을까?
      - ex. 최종적으로 찾는 목표가 카운트 배열이라면 중간 과정을 어떻게 가공하면 될지 고려해보기
      - 연속한 1의 개수 / 부분집합 / 조합 / 순열 → 이런 문제를 풀고 그래프 / 트리의 입력으로 단계가 나눠지기도 함
    - 뒤에서부터 생각해서 문제를 풀 수 있을까?
    - 특정 형태의 답만을 고려할 수 있을까? 

### 복잡도 분석
- 알고리즘의 효율
  - 공간적 효율성과 시간적 효율성

## 비트 연산
#### 비트연산자
|연산자|연산자의 기능|
|---|---|
|&|비트단위로 AND 연산, bit & 0 → 무조건 0, bit & 1 → 원래 bit 그대로, 특정 비트를 0으로 만들 때, binary counting 비트 검사로 활용|
|||비트단위로 OR 연산, bit 와 0 → 원래 bit 유지, bit 와 1 → 특정 bit를 1로 만들때|
|^|비트단위로 XOR 연산(같으면 0, 다르면 1), 특정 비트 반전 (bit = 0 if but else 1) == (bit = bit ^ 1) - 토글|
|~|단항 연산자로서 피연산자의 모든 비트를 반전시킴|
|<<| 피연산자의 비트 열을 왼쪽으로 이동시킴|
|>>| 피연산자의 비트 열을 오른쪽으로 이동시킴 |

- 1 << n
  - 2 ^ n의 값을 가짐
  - 원소가 n개일 경우의 모든 부분집합의 수

- i & (1 << j)
  - 계산 결과는 i의 j번째 비트가 1인지 아닌지를 검사함
  - ex. 2번 비트가 1이면 이 연산의 결과가 0이 아님
  - 해당 개념은 binary coutning으로 부분집합 만들기, 추후에 dp 등 더 공부하면 활용처가 존재함

[practice] 비트 연산 예제1 (-5부터 6까지 비트로 표시하기)
```python
def Bbit_print(i):
    output = ""
    for j in range(7, -1, -1):
        output += "1" if i & (1 << j) else "0"
    print(output)

for i in range(-5, 6):
    print("%3d = "%i, end='')
    Bbit_print(i)
```

PROBLEM1. 0과 1로 이루어진 1차 배열에서 7개 bit를 묶어서 10진수로 출력하기
[practice] 비트 연산 예제2 (16진수)
%X : 16진수로 표현하라는 의미

#### 엔디안(Endianness)
고정된 크기의 메모리를 사용함.
ex. a = 10, [... 1010]가 메모리 상에 저장될 땐?
기본적으로 4byte를 씀
낮은 자리값이 빠른 주소에 저장되는 방식 → 리틀 엔디안
데이터 주고받을 때, byte 단위로 전송하는 경우 많음. 이때 어떤 순서로 byte를 잘라서 보내느냐에 따라 빅 엔디안/리틀 엔디안이 나뉨. 어떤 거를 먼저 보내느냐를 미리 알고 있어야 하고, 내가 받아서 내가 쓰는 시스템의 순서로 재배치해야 할 수도 있음

[practice] 비트 연산 예제4
(1 << 3) | (1 <<> 5) -> 3번 비트와 5번 비트가 1인 값
[practice] 비트 연산 예제4

## 진수
2지니법 -> 16진법(자리수 줄여서 표현 가능) : 4자리씩 묶음
2진법 -> 8진법 : 3자리씩 묶으면 됨

- 컴퓨터에서의 음의 정수 표현 방법
1. 1의 보수
  - 부호와 절대값으로 표현된 값을 부호 비트를 제외한 나머지 비트들을 0, 1을 서로 변환한다.
2. 2의 보수
  - 1의 보수방법으로 표현된 값의 최하위 비트에 1을 더한다.
  - -6 : 1 1 1 1 1 0 1 0 
  - 6 : 0 0 0 0 0 1 1 0 -> 둘이 더해서 8비트로 잘라서 보면 결국 0임


## 실수
- 실수의 표현
  - 소수점 이하 4자리를 10진수로 나타내보면
  - 간격이 존재하고, 이 간격에 위치한 해당 숫자들 사이 숫자를 표현하고 싶을 땐, 소수점 4자리로는 안된다는 뜻. 4바이트 가지고 표현할 수 없으니 바이트를 늘려야 하는 문제 발생 -> 오차 발생 가능
  - 2진 실수를 10진수로 변환하는 방법

- 실수의 표현 IEEE754
컴퓨터는 실수를 표현하기 위해 부동 소수점 표기법을 사용한다
- 실수를 저장하기 위한 형식
  - 단정도 실수(32비트) float
  - 배정도 실수(64비트) double - (실수형일 때 기본형으로 사용함 : 유효자리수가 중요함!)

- 단정도 실수의 가수 부분을 만드는 방법
  - 정수부의 첫 번째 자리가 1이 되도록 오른쪽으로 시프트
  - 소수점 이하를 23비트로 만듦 -> 가수부 23비트
  - 지수부에 3을 통해서 원래 값을 찾아갈 수 있음
  - 지수 부분을 만드는 방법 : 지수부에는 8비트를 배정, n비트면 2^n만큼 만들 수 있는데 이때 익세스 표현법을 사용함
  - 양쪽 숫자가 둘 다 소수점이 왔다갔다 할 수 있어서 이 범위 커지면 소수점 저장할 수 있는 자리가 줄어듦. 이러다보면 오차가 생각보다 커질수 있음 -> so 비트를 많이 쓰는 게 좋고, double형을 기본형으로 쓰라고 권장됨

- 컴퓨터는 실수를 근사적으로 표현한다.
  - 생기는 작은 오차가 계산 과정에서 다른 결과를 가져온다.

- 파이썬에서의 실수 표현 범위
  - inf : 느림, minV은 문제마다 달라지는 것으로 쓰도록 하고 이는 쓰지 않도록 함

<연습문제3> 암호비트패턴 찾아 출력하기

```python
import struct
a = 9.187500
bits, = struct.unpack('I', struck.pack('f', a))
print(f'{vits:032b}')

# 0 / 10000010 / 00100110000000000000000
```
실수형으로 했울 때 무조건 정밀해지는 것이 아님, 오히려 오차가 발생하는 경우도 많음 -> 따라서, 먼저 100을 곱해서 정수형으롤 만들어놓고 계산을 마친 뒤 다시 나누기 100으로 하는 경우도 O

```python
b = 0.1
print(f'{b:.20f}')

# 0.100000000...555
```
