# 그래프

- 그래프 유형
  - 무향 그래프
  - 유향 그래프
  - 가중치 그래프
  - 사이클 없는 방향 그래프
  - 완전 그래프
  - 부분 그래프
- 그래프 경로
  - 경로 중 한 정점을 최대한 한번만 지나는 경로 → __단순경로__
  - 시작한 정점에서 끝나는 경로 → __사이클__

- 그래프 표현
  - 인접 행렬 : |V| X |V| 크기의 2차원 배열을 이용해서 간선의 유무를 저장
  - 인접 리스트 : 각 정점마다 해당 정점으로 나가는 간선의 정보를 저장
  - 간선의 배열 : 간선을 배열에 연속적으로 저장

#### 인접 행렬
- 진출차수 : n에서 출발해서 갈 수 있는 곳 개수
- 진입차수 : n으로 진입하는 정점의 개수
- 단점
  - IF 정점 10000개 정도 -> 인접행렬보다 인접 리스트를 이용해야 할 것이라 예상하고 풀어야 함

__NOW__ 그래프로 표현된 자료구조에서 어떻게 돌아다닐 것이냐? 그래프 순회(탐색)
- 그래프 순회는 비선형구조인 그래프로 모든 자료(정점)를 빠짐없이 탐색하는 것
- 두 가지 방법
  - DFS
  - BFS

### DFS(깊이 우선 탐색)
가장 마지막에 만났던 갈림길의 정점으로 되돌아가서 다시 깊이 우선 탐색을 반복해야 하므로
- 후입선출 구조의 스택 사용
- 재귀 사용 → NxN > 1000 이 되면 반복구조를 써서 탐색을 하라는 크기!
- 스택 포인터 top으로 구현하면 빠름, 문제풀이 상황에서는 스택의 크기를 정해놓고, 그걸 최대로 활용, 정점의 개수만큼만 준비, deque

- DFS 재귀
- DFS 반복
  - 구현 방법 많음 -> 1. Stack 이용 (DFS 때 필요한 건 지나온 갈림길 중에 가장 가까운 애를 어떻게 저장? 재귀로 하면 돌아가면 정점의 정보를 남겨둬서 리턴해가면 있음)
  - 지나간 정점을 저장하는 방식
  - 갈림길을 직접 저장
  - 경로 저장하는 경우는 중복해서 stack에 push하게 될 수도 있음
  - push, visited를 묶어서 사용하는 방식 -> 중복돼서 들어가진 않는데 실제 어떤 경로를 거쳐서 갔는지 알기 힘듦(건너뛰었기 때문
  - )
  
- 목적에 맞는 탐색 중요!
: 지나간 경로 저장해야겠네 / 정점을 빠지지 않고 도는 게 중요한 문제구나 / 얘는 경로의 개수 세야하니까 중복을 허용해야겠구나, visited 체크한 걸 지워야겠구나...

### BFS
탐색 시작점의 인접한 정점들을 먼저 모두 차례로 방문한 후에, 방문했던 정점을 시작점으로 하여 다시 인접한 정점들을 차례로 방문하는 방식
```
BFS(G, v)
    큐 생성
    시작점 v를 큐에 삽입
    점 v를 방문한 것으로 표시
    
    while 큐가 비어있지 않은 경우
        t <- 큐의 첫번째 원소 반환
        for t와 연결된 모든 선에 대해
            u <- t의 인접 정점
            u가 방문되지 않은 곳이면,
            u를 큐에 넣고, 방문 표시
```

### 서로소 집합(Disjoint-sets)
서로소 or 상호배타 집합들은 서로 중복 포함된 원소가 없는 집합들

- 상호배타 집합을 표현하는 방법

### 상호배타 집합 표현 - 트리
현재 정점을 인덱스로, i가 가리키는 애를 tree[i]에 저장

Union(d, f)
1. d의 대표원소를 찾고
2. f의 대표원소를 찾ㅈ아서
3. f의 대표원소를 d의 대표원소로 교체

### 상호배타 집합에 대한 연산
- Make_Set(x) : 유일한 멤버 x를 포함하는 새로운 집합을 생성하는 연산
```python
Make-Set(x)
    p[x] = x
```
- Find_Set(x) : x를 포함하는 집합을 찾는 연산 - 대표원소를 리턴함
```python
# while문으로 찾는 방법(권장)
while p[x] != x:
    x = p[x]
return x
```
```python
# 재귀로 하는 방법
Find_Set(x)
    if x == p[x]
        return x
    else
        return Find_Set(p[x])
```
- Union(x, y) : x와 y를 포함하는 두 집합을 통합하는 연산
```python
Union(x, y)
    p[Find_Set(y)] <- Find_Set(x)
```
- 연산의 효율을 높이는 방법 - 추후에 공부하기
1. 랭크를 이용한 Union의 예
2. Path Compression의 예
- 편향 트리와 같은 구조라면 find_set()으로 대표값을 여러번 반복해서 찾아야 하는데, 이 경우에는 집합의 대표값을 최종 루트값으로 채워놓음
```python
# 3. 재귀 - 경로 압축(부모 노드를 대표값으로 만듦)
def find_set(node):
    if node != parent[node]:
        parent[node] = find_set(parent[node])
    return parent[node]
```
<br>

## 최소 비용 신장 트리 (MST)
- 그래프에서 최소 비용 문제
  - 모든 정점을 연결하는 간선들의 가중치의 합이 최소가 되는 트리
  - 두 정점 사이의 최소 비용의 경로 찾기 or 간단하게 최소 비용 자체를 찾기

- 신장 트리
  - n개의 정점으로 이루어진 무방향 그래프에서 n개의 정점과 n-1개의 간선으로 이루어진 트리
  - 모든 노드가 연결되어 있지만 순환되는 구조인 사이클은 없어야 함
- 최소 신장 트리
  - 무방향 가중치 그래프에서 신장 트리를 구성하는 간선들의 가중치(간선의 비용)의 합이 최소인 신장 트리

- 프림 vs 크루스칼?
크루스칼은 간선 위주, 프림은 정점 위주이다. 대개 크루스칼을 위주로 쓰긴 하지만, 만약 간선이 너무 많은 경우에는 프림으로 heap을 이용한다면 더욱 효율적일 수 있다.

### Prim 알고리즘
하나의 정점에서 연결된 간선들 중에 하나씩 선택하면서 MST를 만들어가는 방식
1. 임의 정점을 하나 선택해서 시작
   - 모든 정점은 MST에 포함되기 때문에 아무 정점에서 시작해도 됨
2. 모든 정점들 중 현재 MST에 포함되지 않으면서 현재 정점에 인접하는 정점들 중에 최소 비용의 간선이 존재하는 정점을 선택
3. 새로운 원소가 더해진 새로운 MST의 정점 중 현재 MST에 없으면서 인접하는 정점들 중 또 최소 비용 간선을 가지는 다른 정점 선택하고 모든 정점이 선택될 때까지 이를 반복

__필요한 정보__
visited, distance 리스트
- visited[v] = True → v가 MST에 포함되어 있음
- distance : MST에서 v로 가는 간선 비용
- KRUSKAL과 다르게 정점을 선택하기 때문에 인접리스트 graph를 만들어야 함\

서로소인 2개의 집합 정보를 유지 → visited처럼 0, 1으로 구분 가능
- 트리 정점들 : MST를 만들기 위해 선택된 정점들
- 비트리 정점들 : 선택되지 않은 정점들

- 알고리즘
1. key[0] <- 0에 대하여 key 값이 최소인 u 검색
2. u <- 0
3. MST[u] MST에 key 값이 최소인 u를 검색해서 걔를 MST에 포함시킴
4. 나머지 정점에 대해서 0~6번까지 아직 MST에 포함되지 않은 정점들 중 인접인 경우 중에서 고르고
```
for v : 0 -> V번 까지
    if MST[v] == 0 and adjM[u][v] > 0 (즉, 가중치가 있으면)
        key <- min(key[v], adjM[u][v]) 랑 연결되는 비용
```
- prim의 단점 : 정점 개수가 너무 많아지면 인접 행렬의 경우 낭비가 심하기 때문에 edge 상태로 저장해서 kruscal 돌리는 게 간단할 수 있음

```python
def prim2(r, V):
    MST = [0] * (V + 1) # MST 포함 여부를 알 수 있는 리스트
    MST[r] = 1          # 시작 정점 MST에 포함되었다고 표시
    s = 0               # MST 간선의 가중치 합

    for _ in range(V):  # V개의 정점을 추가해가면 되는데
        u = 0           # 일단 최소인 애를 찾을 건데
        minV = 100000

        for i in range(V + 1):  # MST에 포함된 정점 i와 인접한 정점 j 중 MST에 포함
            if MST[i] == 1:
                for j in range(V + 1):
                    if adjM[i][j] > 0 and MST[j] == 0 and minV > adjM[i][j]:
                        u = j
                        minV =adjM[i][j]
        s += minV
        MST[u] = 1
    return s
```
```python
def prim(start):
    visited = [False] * (n + 1) # MST에 포함 여부 리스트
    distance = [INF] * (n + 1)  # 정점 v가 MST에 속한 정점과 연결된 간선의 비용
    distance[start] = 0         # 출발점이니까 비용 0으로 잡고 출발
    cost = 0                    # MST의 비용 총합(==최소비용)

    # 정점의 개수만큼 반복하면서 모든 정점을 이은 MST 생성
    for _ in range(n):
        # 1. MST에 포함된 정점에서 이동할 수 있는 모든 정점 중 최소 비용 정점 찾기
        min_dist = INF
        for i, dist in enumerate(distance):
            if not visited[i] and dist < min_dist:
                min_node = i
                min_dist = dist

        # 2. 해당 정점을 MST에 포함하고 비용을 더함
        visited[min_node] = True
        cost += min_dist

        # 3. 바뀐 visited에 따라 해당 정점과 인접한 정점에 대해 달라졌을 distance 업데이트
        for next_node, dist in graph[min_node]:
            if not visited[next_node] and dist < distance[next_node]:
                distance[next_node] = dist

    return cost


n, m = map(int, input().split())
graph = [[] for _ in range(n + 1)]
INF = 99999999  # 임의의 큰 수

for _ in range(m):  # 간선 개수만큼 도는데
    s, e, w = map(int, input().split())    # 시작 정점, 도착 정점, 비용
    graph[s].append((e, w))
    graph[e].append((s, w))

print(prim(1))
'''
7 11
1 2 32
1 3 31
1 6 60
1 7 51
2 3 21
3 5 46
3 7 25
4 5 34
4 6 18
5 6 40
5 7 51

# 175
'''
```
<br>

### KRUSKAL 알고리즘
간선을 하나씩 선택해서 MST를 찾는 알고리즘
1. 최초, 모든 간선을 가중치에 따라 오름차순으로 정렬
2. Greedy하게 가중치가 가장 낮은 간선부터 선택하면서 트리를 증가시킴
   - 사이클 존재하면 다음으로 가중치 낮은 간선 선택 → __find_set__, **union**을 이용해서 이으려는 두 원소가 같은 대표를 가지면 패스
3. n - 1개의 간선이 선택될 때까지 반복하여 최소 비용 구함

```python
def find_set(x):
    while x != rep[x]:
        x= rep[x]
    return x


def union(x, y):
    rep[find_set(y)] = find_set(x)


V, E = map(int, input().split())
edge = []
for _ in range(E):
    u, v, w = map(int, input().split())
    edge.append([u, v, w])
edge.sort(key=lambda x:x[2])
rep = [i for i in range(V + 1)]     # 대표 원소 배열

N = V + 1   # V가 마지막 정점 번호니까 N은 실제 정점 수
cnt = 0     # 선택한 edge의 수
total = 0   # MST 가중치의 합

for u, v, w in edge:    # 얘를 꺼내서
    if find_set(u) != find_set(v):  # 둘이 다르면 얠 선택할 거야
        cnt += 1
        union(u, v)
        total += w

        if cnt == N - 1 # 간선 수 다 택했다면?
            break
print(total)
```

## 📌 최단 경로
간선의 가중치가 있는 그래프에서 두 정점 사이의 경로들 중에 간선의 가중치의 합이 최소인 경로

- 하나의 시작 정점에서 끝 정점까지의 최단 경로
  - 다익스트라 알고리즘
    - 음의 가중치를 허용하지 않음
    - IF 모든 정점에 대하여 알고 싶을 때, 정점별로 도착 비용 다익스트라 따로따로 돌려서 구할 수도 있음
  - 벨만-포드 알고리즘
    - 음의 가중치 허용

- 모든 정점들에 대한 최단 경로
  - 플로이드-워샬 알고리즘

### Dijkstra 알고리즘
시작 정점에서 거리가 최소인 정점을 선택해 나가면서 최단 경로를 구하는 방식
  - 음의 간선이 없다는 가정 하에 사용 가능함
  - 그리디 알고리즘

- 동작 과정
1) 출발지점 k를 정함
2) distance인데 Prim에서의 distance와 다른 점 : 이건 k에서 v까지의 비용을 저장함
3) 갱신, 근데 간선의 비용이 누적되면서 distance에 저장됨
   - visited : 최단거리가 확정된 정점은 True가 됨
   - distance : 시작점에서부터 그 정점까지의 최소 거리가 누적으로 갱신됨

- 알고리즘
1. U = {s} : 비용 결정된 정점들

2. 모든 정점에 대해서 돌때까지
D[v] : 시작점 s에서 v에 도착하는 최소비용인데 인접 행렬에 있는 값을 그대로 갖고 와서 초기화

3. 모든 정점에 대한 비용이 결정되지 않았으면, 즉, 아직 선택되지 않은 정점이 남아있으면
- 출발지로부터 비용이 최소인 애를 선택하는데 (U에 포함되지 않은 애 중에서)
더 이상 비용이 줄어들 수 없으니 결정
- 그 다음에 인접한 모든 정점에 대해서 출발에서 v까지 가는 비용이 있는데 w에 대한 최소 비용을 찾은 거야, 그럼 w를 거쳐서 v를 가는 비용과 기존 그냥 갔던 비용과 비교해서 걔를 새로운 비용으로 업데이트

4. 최종적으로 남은 D는 출발점에서 각 정점으로 가는 최소 비용이 저장됨
-> [참고] 어떤 경로로 결정됐는지는 누구에 의해 갱신됐는지 기록하거나, 거꾸로 역순으로 찾아가는 방식 등을 이용 가능 

```python
def dijkstra(N, X, adj, d): # N개의 정점, 출발기준은 x, d는 양방향 두번 돌 거라서 줌
    for i in range(N + 1):
        d[i] = adj[X][i]    # X에서 i로 가는 비용 복사해놓음
    U = [X]                 # 초기엔 출발지만

    for _ in range(N - 1):  # N개의 정점 중 출발을 제외한 정점 선택
        w = 0               # w 누가 될지 모르겠으니 0으로 두고
        for i in range(1, N + 1):
            if (i not in U) and d[i] < d[w]:    # 남은 노드 중 비용이 최소인 w
                w = i                           # w는 i로 업데이트
        U.append(w)

        # w 택했으니까 이제 길이 열렸고 기존에 v까지 간 경우 외에도 w를 거친 길도 열렸으니 확인해야 함
        for v in range(1, N + 1):               # 정점 v가(v가 뭐냐면 w를 U에 넣어서 w를 가겠다고 확정했잖아요? 이 w에 인접한 정점들을 다 확인)
            if 0 < adj[w][v] < 1000000:         # w에 인접이면(0에서 10000사이면 여기 길이 열렸다는 뜻)
                d[v] = min(d[v], d[w] + adj[w][v])  # 비용 비교해서 최소로 업데이트


T = int(input())
for tc in range(1, T + 1):
    N, M, X = map(int, input().split())

    adj1 = [[1000000] * (N + 1) for _ in range(N + 1)]  # 인접 행렬
    for i in range(N + 1):
        adj1[i][i] = 0

    for _ in range(M):
        x, y, c = map(int, input().split())
        adj1[x][y] = c  # 출발 -> 도착 비용은 c이다!

    dout = [0] * (N + 1)
    dijkstra(N, X, adj1, dout)  # 나가는 방향의 다익스트라 구하기
    print(dout)
```
[P] 크기가 커지면 최소인 d[w]를 효율적으로 찾는 작업이 중요해짐 → 대부분 우선순위 큐를 구현하는 방식, 제일 작은 값 찾고 그것의 인덱스를 찾는 방식으로도 가능하겠으나 이땐 이미 찾아진 애는 제외하는 경우도 고려해야 함


