# 완전 검색 & 그리디


- 재귀적 알고리즘의 특성을 이해하고 이를 구현하기 위한 재귀 호출에 대해 학습
- 완전 검색의 개념을 이해하고 완전 검색을 통한 문제 해결 방법에 대해 학습
- 조합적 문제에 대한 완전 검색 방법에 대해 이해
  - **순열, 조합, 부분집합**을 생성하는 알고리즘을 학습
- 탐욕 알고리즘 기법의 개념과 주요 특성을 이해 (탐욕 알고리즘 기법을 적용해도 적합한지 등)


## 반복(Iteration)과 재귀(Recursion)
- 반복구조 : 초기화, 조건검사, 반복할 명령문 실행, 업데이트(무한 루트가 되지 않게 조건이 거짓이 되게 함)
- 반복을 이용한 선택정렬
```python
def SelectionSort(A):
    n = len(A)

    for i in range(0, n - 1):
        if A[j] < A[minI]:
            minI = j
    A[minI], A[i] = A[i], A[minI]
```
자기 자신이더라도 무조건 바꾸면 되기 때문에, if문 비교보다 그냥 교환을 권장. 

- 재귀적 알고리즘, 재귀 함수
- Q. return으로 값을 돌려보내지 않는 재귀식? 
- 어떤 상황을 잘 정리해봤더니 트리구조처럼 가고 있더라면? 어느 부분을 봐도 동일하게 생겼으니 f(n)을 이런 구조로 정의할 수 있으면 재귀적인 구조를 먼저 만들어보고 이렇게 해를 얻으면 올바른지 판단해봄! 2) 백 트래킹이 가능하다 -> 반복구조로는 불가능! 재귀로 사용
- 호출 단계에서 고유한 메모리 영역을 차지하게 되니까, 그 값의 저장을 이해해야 함

❓ 반복 vs 재귀
- 해결한 문제를 고려해서 둘 중 방법을 선택
- 추상 자료형(List, Tree 등)의 알고리즘은 재귀적 구현이 간단하고 자연스러운 경우 O
- 입력값 n이 커질수록 재귀 알고리즘은 반복에 비해 비효율적일 수 있음

[참고] 재귀와 반복의 요소
|/|재귀|반복|
| --- | --- | --- |
| 종료 | 재귀 함수 호출이 종료되는 베이스 케이스 | 반복문의 종료 조건
| 수행 시간 | (상대적) 느림 | 빠름 |
| 메모리 공간 | (상대적) 많이 사용 | 적게 사용 |
| 소스 코드 길이 | 짧고 간결 | 길다 |
| 소스 코드 형태 | 선택 구조(if...else) | 반복 구조(for, while) |
| 무한 반복시 | 스택 오버플로우 | CPU를 반복해서 점유 |


## 완전 검색 기법
#### brute-force
- 상대적으로 빠른 시간에 문제 해결(알고리즘 설계)을 할 수 있다
- 문제에 포함된 자료의 크기가 작다면 유용하다
```python
SS(A[0, ..., n], k)
```
- 완전 탐색으로 모든 해답을 찾아보고, 이를 기반으로 그리디 기법이나 dp를 이용해도 같은 답이 나오는지 생각해보는 과정에서 효율적인 알고리즘을 찾을 수 있음 -> 우선 완선 검색으로 접근하여 해답 도출, 성능 개선을 위한 다른 알고리즘을 사용하고 해답을 확정하는 것이 바람직함
- 완전 검색 : 순열, 조합, 부분집합과 같은 조합적 문제들에 대한 brute-force 방법!


## 📌순열
- 다수의 알고리즘 문제들은 순서화된 요소들의 집합에서 최선의 방법을 찾는 것과 관련 있음
  - 예) TSP (Traveling Salesman Problem) : 도시들의 방문 순서를 비용을 최소화하는 방문 순서를 정하는 것. 출발점과 도착점은 정해져 있고, 중간 경유지들을 가능한 모든 순열로 계산해보면 됨, dp 적용해서 푸는 방법도 O
  
- 단순하게 순열을 생성하는 방법
  - {1, 2, 3}을 초함하는 모든 순열을 생성하는 함수
  - 동일한 숫자가 포함되지 않았을 때, 각 자리 수 별로 loop를 이용해 아래와 같이 구현할 수 있음
  ```python
  for i in range(1, 4):
      for j in range(1, 4):
          if i != j:
              for k in range(1, 4):
                  if k != i and k != j:
                      print(i, j, k)
  '''
  1 2 3
  1 3 2
  2 1 3
  2 3 1
  3 1 2
  3 2 1
  '''
  ``` 
  - 최소 변경을 통한 방법
    - 각각의 순열들은 이전의 상태에서 단지 두 개의 요소들의 교환을 통해 생성
    - 개수가 바뀌면? 재귀로 해보자
    - 
- 앞에서 사용할 숫자를 표시하고 가는 방식
이 숫자가 사용됐는지 확인하는 used 변수를 만듦, n번째 자리 결정하는 과정마다 used를 확인해서 사용하지 않아 아직 원소 값이 0인 원소를 사용해서 리스트 a를 채움
-> 3개 골라서 1개 완성 -> return -> 리턴 후 좀 전에 사용했던 얘는 다른 자리에서 사용할 수 있게 used 값을 다시 0으로 돌려줌 -> 그리고 이후에 더 쓸 숫자가 있나? 근데 오른쪽에 더 없으니까 다시 위로 return -> 그 위에서는 오른쪽에 used값이 0인 게 있으니까 3을 쓸 수 있음! -> 101로 used를 바꿔주고 그 다음 자리 정하러 가면 101이니까 2가 아직 0이니까 2를 선택 --> [1, 3, 2]

내가 p에서 k개를 채우는 거면, 쓸 숫자 k개를 확보해놓고, 여기서 가져오는데, 0부터 쭉 used 배열을 뒤지면서 0이면 걔를 쓰겠다 
```python
def f(i, k):
    if i == k:
        print(p)
    else:
        for j in range(k):  # used는 무조건 처음부터 뒤지니까 range(k)
            if used[j] == 0:    # a[j]가 아직 사용되지 않았으면
                used[j] = 1     # a[j]가 사용됨으로 표시
                p[i] = a[j]     # p[i]는 a[j]로 결정
                f(i+1, k)       # p[i+1]값을 결정하러 이동
                used[j] = 0     # a[j]를 다른 자리에서 쓸 수 있도록 해제


N = 3
a = [i for i in range(1, N + 1)]
used = [0] * N
p = [0] * N
f(0, N)
'''
[1, 2, 3]
[1, 3, 2]
[2, 1, 3]
[2, 3, 1]
[3, 1, 2] # exchange와 달리 사전적 순서로 표시됨
[3, 2, 1] 
'''
```
- 전체 원소 중 일부만 뽑는 경우 ex. 5개 중 3개
```python
def f(i, k, r):
    if i == r:
        print(p)
    else:
        for j in range(k):  # used는 무조건 처음부터 뒤지니까 range(k)
            if used[j] == 0:    # a[j]가 아직 사용되지 않았으면
                used[j] = 1     # a[j]가 사용됨으로 표시
                p[i] = a[j]     # p[i]는 a[j]로 결정
                f(i+1, k, r)       # p[i+1]값을 결정하러 이동
                used[j] = 0     # a[j]를 다른 자리에서 쓸 수 있도록 해제


N = 5
R = 3
a = [i for i in range(1, N + 1)]
used = [0] * N
p = [0] * R # 채울 3개만 p에 있으면 됨
f(0, N, 3)  # 주어진 10개 중 3개 고를 경우
```
🧷 앞자리가 항상 1로 고정되고 나머지는 순열로 만드는 법
```python
used = [0] * N
p = [0] * R # 채울 3개만 p에 있으면 됨
p[0] = 1    # 1로 고정할게
used[0] = 1
f(1, N, 5)  # 주어진 10개 중 3개 고를 경우
```


## 📌부분집합
- 바이너리 카운팅을 통한 사전적 순서
  - 원소의 개수가 변해도 간단하게 처리할 수 있는 방안
  - 원소 수에 해당 하는 N개의 비트열을 이용, n번째 비트값이 1이면 n번째 원소가 포함되었음을 의미함

- 재귀 형태
```python
def f(i, k):
    if i == k:
        for j in range(k):
            if bit[j]:  # bit 걔가 0이 아니고 1이면 걔를 출력해봐
                print(arr[j], end=' ')
        print()

    else:
        bit[i] = 0
        f(i+1, k)
        bit[i] = 1
        f(i+1, k)


arr = [3, 6, 7]
n = len(arr)

bit = [0] * n       # bit[i]는 arr[i]가 부분집합의 원소인지 표시
f(0, n)             # 0번부터 채우고, 개수는 n이야
```


## 📌조합
- 재귀 호출을 이용한 조합 생성 알고리즘
인덱스를 활용해도 됨
끝에서부터 넣는 게 인덱스 계산하는 데 쉬움 n - 1이 점점 줄어드는 형식, 그래서 그냥 이대로 쓰면 되니까 인덱스 계산이 간단하다?
if n < r 처럼 말 안 되는 경우가 만들어지는데 어떤 처리 안 해주고, 리턴만 해줌

- 또 다른 방법 [참고]
- 10개의 원소 중 3개를 고르는 조합


- n과 r이 같이 변해도 됨 -> n개에서 r개를 고르는 조합(재귀) / 10개에서 3개 고른 거의 응용 버전
- 10개에서 3개 고르고, 그 3개로 뭘 하고, 다시 3개 고르고... 이런 문제도 있음

1) 선택(순열/부분집합/조합)
2) 행동
3) 결과 비교
4) 그리고 모든 가능한 경우를 만족할 때까지 1로 돌아감

<연습문제3>
모든 경우를 다 만들어야 하니까, 바이너리 카운팅을 고려해보는 게 효율적


## 탐욕 알고리즘
각 선택 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 해서, 그것이 최적이라는 보장은 없다.
- 일단 한 번 선택된 것은 번복하지 않는다.
- 최적화 문제? 가능한 해들 중에서 가장 좋은 해를 찾는 문제
- 동작과정
  - 해 선택 : 하나 골라보고
  - 실행 가능성 검사 : 고를 수 있는 건가?
  - 해 검사 : 해가 되는 게 아니면 반복
  
- 거스름돈 줄이기
- 배낭 짐싸기
  - 완전 검색 방법
    - 물건들의 집합 S에 대한 모든 부분집합
    - 총무게가 W를 초과하는 집합은 버리고, 나머지 집합에서 총합이 가장 큰 값 선택
    - BUT 시간복잡도 지수적으로 증가
  - 탐욕적 방법1, 2, 3 -> 불가능
  - DP, 백트래킹
- Fractional Knapsack 문제

#### 활동 선택 문제
- 탐욕 기법을 적용한 반복 알고리즘
  - 종료시간이 빠른 순서로 활동들을 정렬
  - 첫 번째 활동 A1을 선택
  - 선택한 활동의 종료시간보다 빠른 시작 시간을 가지는 활동을 모두 제거
  - 남은 활동들에 대해 앞의 과정을 반복

- 재귀 알고리즘

#### 탐욕 기법을 통한 Baby-gin 문제
2가지 방법
```python
'''
5
123123
124467
333444
444456
123444
'''
def f(i, k):
    global ans

    if i == k:
        run = 0
        tri = 0
        if card[0] == card[1] and card[1] == card[2]:
            tri += 1
        if card[0] + 1 == card[1] and card[1] + 1 == card[2]:
            run += 1
        if card[3] == card[4] and card[4] == card[5]:
            tri += 1
        if card[3] + 1 == card[4] and card[4] + 1 == card[5]:
            run += 1
        if tri + run == 2:
            return 1
        else:
            return 0
    else:
        for j in range(i, k):
            card[i], card[j] = card[j], card[i]
            # 이제 다음 자리 결정하러 가자
            if f(i+1, k):   # 리턴값 1이면 중단
                return 1
            card[i], card[j] = card[j], card[i]
        return 0    # for문 다 돌았는데 여기 안 걸렸으면 0 리턴


# 완전 탐색 기법
T = int(input())
for tc in range(1, T + 1):
    card = list(map(int, input()))
    # 이제 순열 만들 차례
    ans = f(0, 6)
    if ans:
        print(f'#{tc} Baby Gin')
    else:
        print(F'#{tc} Lose')
```

