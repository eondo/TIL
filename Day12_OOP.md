### Introduction
- 객체지향 프로그래밍(OOP)
  - 객체 지향 프로그래밍이란?
  - OOP 기초
    - 객체/인스턴스/클래스
    - 클래스
    - 메서드
- 객체지향의 핵심 개념
  - 추상화
  - 상속
  - 다형성
  - 캡슐화
- 에러와 예외

### 객체 지향 프로그래밍
각각의 객체는 메시지를 주고받고 데이터를 처리할 수 있음  
프로그램을 여러 개의 독립된 객체들과 그 객체 간의 상호작용으로 파악하는 프로그래밍 방법
- 객체 : 정보와 행동을 묶어서 변수처럼 이름을 붙이면 그게 객체, 변수 + 함수
- 디테일 한 건 모르지만 추상화를 통해 가수가 노래를 어떻게 하는지 몰라도 꾸러미를 들고와서 쓸 수 있음, 현실 세계를 프로그램 설계에 반영(추상화)

- 객체지향의 장점/단점
  - 장점
    - 클래스 단위로 모듈화시켜 개발할 수 있으므로 많은 인원이 참여하는 대규모 소프트웨어 개발에 적합
    - 필요한 부부만 수정하기 쉽기 때문에 프로그램의 유지보수가 쉬움
  - 단점
    - 설계 시 많은 노력과 시간이 필요함
      - 다양한 객체들의 상호 작용 구조를 만들기 위해 많은 시간과 노력이 필요
    - 실행 속도가 상대적으로 느림
      - 절차 지향 프로그래밍이 컴퓨터의 처리구조와 비슷해서 실행 속도가 빠름

### OOP 기초
## 객체
클래스에서 정의한 것을 토대로 메모리(실제 저장공간)에 할당된 것으로 프로그램에서 사용되는 데이터 또는 시결자에 의해 참조되는 공간이며 변수, 자료 구조, 함수 또는 메서드가 될 수 있음
- '속성'(변수)과 '행동'(메서드)으로 구성된 모든 것
- 파이썬의 모든 것이 객체(object)

- 클래스와 객체
  - 클래스(설계도) : 가수 / 객체(실제 사례) : 이찬혁
  - 클래스 -> 타입(list) : 클래스를 만든다 == 타입을 만든다
  - [1, 2, 3], [1], [], ['hi'] : 모두 리스트 타입(클래스)의 객체
  - 
- 객체와 인스턴스
  - 특정 클래스로 만든 객체 : 인스턴스
    - 객체 vs 인스턴스
      - 객체(이찬혁)는 특정 클래스(가수)의 인스턴스다(O)
      - 객체(이찬혁)는 인스턴스가 (X)
  - 객체는 특정 타입의 인스턴스이다.
    - ex. 123, 900, 5는 int의 인스턴스
    - ex. 'hello, 'bye'는 string의 인스턴스

- 객체란
  - 객체(object)의 특징
    - 타입(type) : 어떤 연산자(operator)와 조작(method)이 가능한가?
    - 속성(attribute) : 어떤 상태(데이터)를 가지는가?
    - 조작법(method) : 어떤 행위(함수)를 할 수 있는가?

~
~
다시 채우기
~
~

- 객체 비교
  - == : 동등한, 변수가 참조하는 개체가 동등한(내용이 같은) 경우 True, 두 객체가 같이 보이지만 실제로 동일한 대상을 가리키고 있다고 확인해 준 것은 아님
  - is : 동일한(identical), 두 변수가 동일한 객체를 가리키는 경우(주소까지 같으면) True

### 속성
특정 데이터 타입/클래스의 객체들이 가지게 될 상태/데이터를 의미
클래스 변수/인스턴스 변수가 존재
```
class Person:
    blood_color = 'red' # 클래스 변수
    population = 100 # 클래스 변수 (같이 쓰는 거)

    def __init__(self, name):
        self.name = name # 인스턴스 변수(각자 쓰는 거)

person1 = Person('지민')
print(person1.name) # 지민
```
잠깐 정리 : 객체(정보+행동) 여기서 정보 -> (클래스변수, 인스턴스 변수)로 2개가 있다

### 인스턴스 변수
인스턴스가 개인적으로 가지고 있는 속성(attribute)으로 각 인스턴스들의 고유한 변수
- 생성자 메서드(__init__)에서 self.<name>으로 정의 (만들고)
- 인스턴스가 생성된 이후 ??? (사용)
```
class Person:

    def __init__(self, name): # name -> 인스턴스 변수 정의, self -> 자동으로 자기자신
        self.name = name 
        self.ㅇㅇ = ㅇㅇ
        ...

john = Person('john')
print(john.name) # john # 인스턴스 변수 접근 및 할당
john.name = 'John Kim' # ''
print(john.name) # John Kim 
```
### 클래스 변수
- 클래스 선언 내부에서 정의
- <classname>.<name>으롤 접근 및 할당
인스턴스 def 여기 안에 없네? 그럼 올라가서 클래스 변수(pi)를 가져옴 ('인스턴스.클래스변수'가 가능하다, 그리고 Circle.pi = 5로 바꾸면 다른 애들도 다 바뀐다. 공용이니까. 근데 c1.pi = 10이라고 하면? 안에 pi 없으니까 새로 만든다. 따라서 c1.pi만 10이 print된다)
클래스 변수, 인스턴스 변수 2개가 있고 전자 : 공용, 후자 : 각자 개인용
이 상황에서 살펴보면 

ex. 인스타그램 유저
유저수 정보는 클래스 변수로 만들어야 할까요 아님 인스턴스 변수로 만들어야 할까요? 클래스 변수. 개인에 따라 달라지는 게 아니기 때문에! 공용으로 쓸 건 클래스 변수로 만든다. + ex. iterable이런 건 클래스변수이다.
~~
~
끊김
~~
~
#### 클래스 변수 활용(사용자 수 계산하기)
def ~ 생성자
하나하나 만들어질 때마다 하면 count가 하나씩 들어난다
ex. 실시간 채팅하는 유저 수는 이렇게 해야겠지?

#### 클래스 변수와 인스턴스 변수
클래스 변수를 변경할 때는 항상 클래스.클래스변수 형식으로 변경

새로운 인스턴스 변수가 생성됨
이 문제를 해결하기 위해서는? 클래스 변수를 변경할 때 무조건 '클래스.클래스변수' 형식으로 바꿔라 
인스턴스.인스턴스변수

## OOP 메서드
클래스 안에 있는 함수다!
- 메서드의 종류
  - 인스턴스 메서드 : 인스턴스 (변수 같은 것을)를 처리
  - 클래스 메서드 : 클래스를 처리
  - 정적 메서드 : 나머지 (인스턴스랑 클래스 모두랑 상관 없으면)

### 인스턴스 메서드
인스턴스 변수를 사용하거나, 인스턴스 변수에 값을 설정하는 메서드
클래스 내부에 정의되는 메서드의 기본
호출 시, 첫번째 인자로 인스턴스 자기자신(self)이 전달됨
-> my_inst가 def의 (self, ...)으로 자동으로 들어감, 쉽게 생각하면 : self가 있으면 인스턴스 메서드!
#### self

#### 생성자 메서드
person2 = Person('싸피') # 인스턴스가 생성되었습니다. 싸피 -> name은 각자 쓰는 거

#### 매직 메서드
특수한 동작을 위해 만들어진 메서드로, 특정 상황에 자동으로 불리는 메서드
print했을 때 입력값이 덧붙여지는 듯이 동작이 바뀌게 하고 싶다 --> __str--(self)
- 객체의 특수 조작 행위를 지정(함수, 연산자 등)
  - __GT__ 키 말고 돈, 매력지수 등 다른 걸로도 비교할 수있다
#### 소멸자 메서드
생성자(만들 때 되는 게 있고), 소멸자(없어질 때 실행되는 게 있다)


### 클래스 메서드
클래스가 사용할 메서드, 쉽게 생각하면 : cls 있으면 클래스메서드

- 데코레이터
  - 함수를 어떤 함수로 꾸며서 새로운 기능을 부여
  - @데코레이터(함수명) 형태로 함수 위에 작성
  - 순서대로 적용됨
- 사용 예시 (조금 어려움)
```
original이 있고 original을 받아서 위 아래에 함수시작과 함수끝을 붙여서 original함수를 꾸며주는 코드다. 가운데 뭔가 들어오면 위아래에 뭘 더하는 기능이다~ hello를 add print 넣으니까 함수시작 함수끝이라는 데코가 붙는다. 얘를 왜 쓰냐? 여러가지 인삿말이 있을 텐데 안녕, 봉주르... 등등 여러가지 함수를 꾸며주고 싶으면 얘를 쓴다. 온갖 안녕print def, 봉주르print def 등등 이 모든 함수마다 다 붙여놓으면 수정하기 쉽지 않겠지?
-> 근데 얘도 귀찮아서 데코레이터 사용!

add_print 데코레이팅 함수를 만들어놓고 이걸 붙이고 싶은 def 위에 @add_print만 달아주면 변한다!
```
#### 클래스 메서드 vs 인스턴스 메서드
클래스는 cls 쓰고, 인스턴스는 self 쓰고
둘 다 쓰고 싶은 경우는?
클래스는 인스턴스 변수 사용이 불가능함

ex. Class.blood_color
instance.인스턴스변수
이 둘 다 고치고 싶을 수도 있잖아? 이땐 인스턴스 메서드를 쓰면 된다!

### 스태틱 메서드
- 속성을 다루지 않고(즉, 데이터의 변화 없이) 그냥 기능만을 하는 메서드를 만들고 싶을 때 사용
- @staticmethod 데코레이터 사용
- 클래스 안에 있음
- 사용 예시
```

```
많이 쓰진 않는다

#### 인스턴스와 클래스 간의 이름 공간
인스턴스에서 찾고 없네?, 그럼 클래스로 간다
```
p1.talk하면 왜 unknown하면? self.name을 안 만들어줘서 없으니까 그 위로 가서 unknown이 출력됨.
p2.name에는 'Kim;을 수동으로 넣음. 출력이 됨.

클래스 변수는 기본적으로 unknown이 뜨고, 없으면 위로 가서 찾는다
마지마가 print 줄 : 여기서 p2.name은 인스턴스 변수고, unknown은 클래스 변수를 찾아온 것. 문법은 같은데 결과는 다름
p1은 인스턴스 변수가 정의가 안 되어있어서 없으니 위에서 클래스에서 찾으니까 unknown이 나옴
```

### 메서드 정리 (오후 라이브)
공부할 때 메서드를 정리하면 자연스럽게 변수들이 정리된다!
- 인스턴스 메서드
  - 호출한 인스턴스를 의미하는 self 매개 변수를 통해 인스턴스를 조작
- 클래스 메서드
- 스태틱 메서드 (ex. add_age(?) 들어와서 +1 하는 것 같이 간단한 함수 만들고 싶을 때)

@classmethod(함수이름) print, sum처럼 원래 정해져있는 것

### 예시
```
MyClass라는 설계도로 인스턴스를 만들고
## obj가 그냥 인스턴스고 이게 만들고
## obj.method() 써도 그냥 나옴. 인스턴스라고. 인스턴스 obj. obj가 괄호로 들어가서 self로 들어간다.
## 근데 이렇게도 쓸 수 있다는 거. 위에건 obj 안 넣었는데 저절로 들어감. 권장되는 방법은 아님. obj를 수동으로 넣는 법.

# 클래스 자체에서 각 메서드를 호출하는 경우
- 클래스. 하고 인스턴스 메서드는 호출할수 없음

# 인스턴스는 클래스 메서드와 스태틱 메서드 모두 접근할 수 있음
왜냐면 인스턴스가 가장 작은 방이니까 없으면 바깥 공간에서 확인하면 되니까
```

### 객체지향의 핵심 개념
- 추상화
- 상속
- 다형성
- 캡슐화

### 추상화
변수, 함수, 클래스 보통 이 3개를 얘기함.

### 상속
두 클래스 사이 부모-자식 관계를 정립하는 것
모든 파이썬 클래스는 object를 상속 받음

- 문법 : class ChildClass(ParentClass):
- 하위 클래스는 상위 클래스에 정의된 속성, 행동, 관계 및 제약 조건을 모두 상속 받음
- 부모클래스의 속성, 메서드가 자식 클래스에 상속되므로, 코드 재사용성이 높아짐

- 상속 정리
  
#### 다중 상속
두 개 이상의 클래스를 상속 받는 경우
- 중복된 속성이나 메서드가 있는 경우 상속 순서에 의해 결정됨

### 캡슐화
쓸 수는 있는데, 안에 있는 민감 정보를 숨겨 볼 수 없음
공식적으로는 존재하지 않음
못 볼 수 있게 하는 것이자 못 고치게 하는 것 - getter, setter

- 접근제어자 종류
  - Public Access Modifier
  - Protected
    - 언제 쓰냐면 민감 정보들을 직접적으로 조회하는 건 좀 별로. get_information하면 뭐가 와라락 나오게끔하고 직접적으로 건드리지 않도록 함
    - p1._age = 30이라고 바꿀 수도 있긴 하지만 이렇게 막 바꾸진 말고 절차를 통해서 바꾸게 하고 싶을 때 self._age ~ 사용?
  - Private (가린다)
    - get age로는 가져올 수 있지만 직접 접근은 불가능
    - 직접 접근 대신 가져오는 법 : getter 메서드, setter 메서드
  ```
  class Person:
      def __init__(self, age):
          self._age = age
      
      @property
      def age(self):
          return self._age

      @age.setter
      def age(self, new_age):
          if new_Age <= 19:
              raise ValueError('too young')
              return

          self._age = new_age
          ## 데이터에 잘못된 값이 입력되는 걸 막기 위해서 이런 처리를 함
  ## 캡슐안에 데이터를 바꾸는 로직을 setter를 만들어서 숨김
  _ 언더바 있어도 직접 접근이 가능한 이유는 getter @property 덕에 얘가 _age를 그냥 age로 바꿔버림
  ## p1.age = 19 를 쓰면 그냥 값 변경하는 것 같은데 사실 이게 @age.setter, @property 이런 곳에 들어가서 함수가 실행되고 있다. 우리 눈엔 그게 보이지 않고. 
  ```

