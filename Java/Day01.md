1. 자바 기본
   1. 변수, 연산자, 제어문
2. 배열, 다차원 배열
3. 객체지향 프로그래밍
4. 변수
5. 메서드
6. 생성자

클래스를 접근하는 3가지 방법
```
// 1. 클래스 이름.class
Class<?> clz = Dog.class;

// 2. Class.forName("패키지 포함 클래스명")
Class<?> clz2 = Class.forName("com.ssafy.reflection.Dog");

// 3. 객체(인스턴스).getClass()
Dog d = new Dog();
Class<?> clz3 = d.getClass(); 
```

## Variable
- 메모리 공간에 값 할당 후 사용
- 타입에 따라 크기가 달라짐
- 기본형 vs 참조형
 - 기본형 : boolean, byte, short, int(* 32bit, 20억 쯤), long, float, double(*), char
   - 부동소수점 double으로 연산하면 부정확한 결과가 나올 수 있음을 유의 -> 유효 자리수를 이용한 반올림 처리, 정수형으로 변환 후 계산
   - 90 / 100 => 0, 90 / 100.0 = 0.9

## 형 변환 
- primitive, reference끼리 형 변환 가능
- 기본 타입과 참조형의 형 변환을 위해 Wrapper 클래스(Integer.~) 사용
- 방법(형 변환 연산자(괄호) 사용)
  - ```java 
    double d = 100.5;
    int result = (int)d; // result = 100
    ```
- 묵시적 형 변환
  - 작은 데이터 타입 -> 큰 데이터 타입 (값 손실 X), 값의 크기, 타입의 크기가 아닌 표현 범위가 커지는 방향으로 할당할 경우는 묵시 적 형변환 발생
  - ```java
      byte b = 10;
      int i2 = b
      ```
- 명시적 형 변환
  - ```java
      int i = 300;
      byte b = (byte)i;
      ```

## 연산자
- 산술 이항 연산자는 연산 전에 피 연산자의 타입을 일치시켜야 함 (산술의 최소 단위는 int로 변경돼서 연산되기 때문에 byte를 int롤 변경한 후 연산 진행)
- 두 개의 피연산자 중 큰 타입으로 형 변환 후 연산 진행
- || : 앞이 true면 뒤는 볼 필요가 없기 때문에, 뒤에 존재하는 연산은 진행하지 않음

## 조건문
### if문
논리형, 비교식, Method Call
### switch문
- 정수호환(byte, short, char, int x;)
- Enum : Day.MONDAY
- Class Object : ...
- Method Call : getNumber()...

## 반복문
### for문
for (변수 초기화; 반복 조건; 증감식) {
  실행문
}

### while문
변수 초기화
while (반복 조건) {
  실행문
  증감식
}

# 배열
타입 [] 변수명;
타입 변수명 []

- int [] arr : arr 배열에 저장되는 데이터의 타입이 int!

### 배열의 생성과 초기화
- 생성
- new int [3]; // int 타입의 자료 3개를 저장할 수 있는 배열을 메모리에 생성
- points = new int [3] // points라는 변수에 할당, 메모리에 있는 배열을 가리키는 reference 타입 변수

- 초기화
- toCharArray()

- Array 만들기 #2
  - 생성과 동시에 할당한 값으로 초기화
  - int [] b = new int [] {1, 3, 5, 6, 8};
  - 유의) int [] b와 값 할당할 코드를 분리해서 쓸 땐 new int를 생략할 수 없음 (선언과 생성이 따로 될 때)

### for-each with Array
반복문의 또 다른 이용 형태로 index 대신 직접 요소에 접근하는 변수를 제공
int intArray [] = {1, 2, 3, 4, 5};

for ( int x : intArray ) {
  System.out.printlin(x);
}
-> index를 사용하지 않아도 되는 경우에 사용!

### Array is immutable
배열 자체는 최초 메모리 할당 이후, 변경할 수 없음
but 배열의 개별 요소는 다른 값으로 변경 가능, 요소를 추가/삭제는 불가능

## 다차원 배열
- 2차원 Array 만들기 #1
  - int [][] intArray
  - int intArray [][]
  - in [] intArray []
- 2차원 Array 선언, 생성, 할당 동시에
  - int [][] intArray = {{}, {}, {}}
- 길이가 정해져 있지 않은 2차원 Array
  - int [][] intArray = new int[4][]
  - intArray[0] = new int[3] : 3칸의 null값이 들어감

# 객체지향 프로그래밍
- 객체지향이란?
  - 블록 형태의 모듈화된 프로그래밍 -> 신뢰성, 추가/수정/삭제 용이, 재사용성
  - 속성과 기능은 클래스에 정의 -> 클래스는 구체화되어 프로그램의 객체(인스턴스, 오브젝트)가 됨
  - 클래스 - 멤버변수, 멤버메서드 -> 객체 : 클래스를 데이터 타입으로 메모리에 생성된 것

### 객체 생성과 메모리
- JVM의 메모리 구조
  - class area : 클래스의 원형이 로딩
  - method stack : 메서드들의 실행 공간, thread 별로 별도 관리
  - heap : 객체를 저장하기 위한 영역, new 키워드로 객체가 생성되는 곳, thread에 의해 공유(즉, heap은 하나!)

QnA
- 메인이 끝나면 스택의 main은 사라지고 메모리에서도 사라진다.

# 변수
변수의 종류
- 타입에 따른 분류
  - primitive type : 기본 8가지 타입 ( int, char, float...)
  - reference type : 나머지 모든 변수(객체 참조)
- 선언 위치에 따른 분류
  - 멤버 변수
    - 클래스 멤버 변수 : 클래스 내부에 static이 붙음
    - 인스턴스 멤버 변수
  - 지역 변수
    - 지역 변수
    - 파라미터 변수

#### 인스턴스 멤버 변수
- 선언 위치 : 클래스 {} 영역
- 변수에의 접근 : 객체 생성 후 객체 이름으로 접근
  - ex. person1.name = "홍길동"

#### 클래스 멤버 변수
- 선언 위치 : 클래스 {} 영역 + static 키워드
- 모든 객체가 공유하게 됨
- 접근 : 클래스 이름(소속)으로 접근 (권장)

? 언제 static을 써야 할지 고민! 
- 정적 : 잘 변하지 않지만 바뀔 수도 있는 값

#### 지역 변수, 파라미터 변수
- 변수의 초기화 : 사용하기 전 명시적 초기화 필요


# 메서드
- 리턴타입 : 호출한 곳으로 반환되는 값의 타입으로 아무것도 리턴하지 않을 경우 void
- 결과를 받을 때 묵시적 형 변환 적용
  - int add(~)라고 하면 결과 받을 때 double도 상관 없음
- 리턴 타입은 하나만 적용 가능
  - 여러 개의 데이터를 넘기려면? -> 동일한 타입의 데이터라면 배열, 다른 타입이라면 클래스의 타입으로 만들어서 객체형으로 반환시킴
- 넘길 인자가 가변적일 경우
  - ...으로 파라미터 선언 시, 호출할 때 넘겨준 값의 개수에 따라 자동으로 배열을 생성 및 초기화
    - public void variableArgs(int... params){}

#### 메서드 호출
#### 메서드 접근
  - static member
    - 같은 클래스 : 바로 호출
    - 다른 클래스 : 클래스_이름.멤버_이름
  - non static member
    - 같 : 바로 호출
    - 다 : 객체_이름.멤버_이름
  - ❗ 중요) 호출하려는 멤버가 메모리에 있는가 : 없는 경우 먼저 객체를 만들어 메모리에 로딩 후 사용
  
#### 기본형 변수와 참조형 변수
메서드 호출 시 파라미터로 입력된 값을 복사해서 전달 (참조형의 경우 주소값이 전달됨)
- call by value?
  - 파라미터로 값 전달할 때 기본형? 참조형? 참조형 값 전달의 경우 참조형 변수를 통해서 원래 있는 객체를 변경할 수 있음!

### 메서드 오버로딩
- overloading : 동일한 기능을 수행하는 메서드의 추가 작성
- 동일한 기능을 여러 형태로 정의해야 할 때 사용 -> 파라미터만 다르게 중복 코드 관리
- 방법 : 메서드 이름 동일, 파라미터 개수/순서/타입이 달라야 함, 리턴 타입의 상관 없음
- 에러 예제(이름은 같고 파라미터의 타입이 다른 경우)
  - 3번 호출은 메서드 호출이 위 아래 다 가능하기 때문에 (변수의 promotion) 모호해짐 -> 동작 불가능
```java
long add(long a, int b){return a+b;}
long add(int a, long){return a+b;}

// 호출
add(3, 5L); // 1
add(5L, 3); // 2
add(3, 4); // 3
```
- 성공 예제
  - 내부적인 동작에서 하는 일은 같은 코드가 중복 시 -> void walk(), void walk(int distance) 안에 walk 함수를 호출하여 void walk(int distance, String unit){}에서 중복 코드를 실행하도록 함

### 생성자
객체를 생성할 때 호출하는 메서드와 유사한 것으로 new 키워드와 함께 호출
- 일반 멤버 변수의 초기화나 객체 생성 시 실행돼야 하는 작업 정리
- 작성
```
제한자 클래스_명(타입 변수_명, 타입 변수_명, ...)
{
  // 멤버 변수 초기화 작업
}
```
- 기본 생성자
- 파라미터가 있는 생성자
  - 생성자의 목적 : 일반 멤버 변수의 초기화 -> 생성자 호출 시 값을 넘겨줘서 초기화

### this의 용법
참조 변수로서 객체 자신을 가리킴 (객체에 대한 참조이므로 static 영역에서는 this 사용 불가)
- 용도
  - 로컬 변수와 멤버 변수의 이름이 동일할 경우 멤버 변수임을 명시적으로 나타냄
  - 명시적으로 멤버임을 나타낼 경우 사용

- this()
  - 생성자도 오버로딩 가능
  - 한 생성자에서 다른 생성자를 호출할 때 사용