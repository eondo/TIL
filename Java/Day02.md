### INDEX
1. 상속
2. 메서드 재정의
3. package & import
4. 접근제한자와 데이터 은닉과 보호
5. 다형성

## 상속
기존 클래스가 가진 자산(멤버 변수, 멤버 메서드...)을 자식 클래스에서 재사용하기 위한 것
- `extends`
- 단일 상속만 지원 -> interface와 포함 관계로 단점 극복 


### Object 클래스
모든 클래스의 조상 클래스
- 별도의 extends 선언이 없는 클래스들은 Object 클래스를 상속받음
- Object 클래스에 정의된 메서드가 존재함 -> 대부분 클래스에서 재정의 해서 사용

### 포함 관계
- has a -> 2개 이상의 클래스에서 특성을 가져올 때 하나는 상속, 나머지는 멤버 변수로 처리
- 어떤 것을 상속으로, 포함으로 줄지는 프로젝트의 관점 문제
```
public class SpiderMan2 extends Person {
  Spider spider;
  ...
}
```

# 메서드 재정의
- 메서드 오버라이딩 : 조상 클래스에 정의된 메서드를 자식 클래스에서 적합하게 수정하는 것
- 오버라이딩의 조건
  - 메서드 이름 동일
  - 매개 변수 개수, 타입, 순서 동일
  - 리턴 타입 동일
  - 접근 제한자는 부모보다 범위가 넓거나 같아야 함
  - 조상보다 더 큰 예외를 던질 수 없음

### toString() 메서드
객체를 문자열로 변경하는 메서드, 주소값이 아니라 내용을 반환하기 위한 오버라이딩 진행
- 단축키 : to + Ctrl + space
- this. : 나의 멤버를 레퍼런스
- `super.` : 조상 클래스 멤버를 레퍼런스

### super 키워드
this() : 해당 클래스의 다른 생성사 호출 -> super() : 조상 클래스의 생성자 호출
- 조상 클래스에 선언된 멤버들은 조상 클래스의 생성자에서 초기화가 이뤄지고, 상속을 받더라도 생성자는 상속이 안 되기 때문에 자식은 자식이 선언한 멤버들만 자식 클래스 생성자에서 초기화하면 됨
- 명시적으로 this() or super()를 호출하지 않은 경우 컴파일러가 super()를 삽입하여 맨 상위의 Object까지 객체가 다 만들어지는 구조임

### package와 import
- package : 모든 클래스는 반드시 하나의 패키지에 속함
  - 네이밍 룰 : 소속.프로젝트.용도
- import : 다른 패키지에서 선언된 클래스를 사용하기 위한 키워드
  - 사용 : import 패키지명.클래스명;
  - 동일한 클래스 이름일 경우 전체 패키지 명을 입력하여 구분

# 접근 제한자 및 데이터 은닉과 보호

### 제한자
클래스, 변수, 메서드 선언부에 함께 사용되어 부가적인 의미 부여
- 종류
  - 접근 제한자
    - public, protected, (default = package), private
  - 그 외 제한자
    - static
    - final : 마지막으로서 더 이상 바뀔 수 없음
    - abstract
    - synchronized

#### final
- 용도
  - final class : 더 이상 확장할 수 없는 클래스로 상속이 금지됨 -> 오버라이드 방지
    - 상속을 못 해야 하는 경우 : 이미 완벽한 클래스일 때,
  - final method : 더 이상 재정의할 수 없음
  - final variable : 더 이상 값을 바꿀 수 없음, 상수화

### 접근 제한자
멤버 등에 사용되며 해당 요소를 외부에서 사용할 수 있는지 설정
- 멤버 관리의 기준, 레벨을 두고 요소를 관리
- private > package > protected > public
- 범위
  - 같은 패키지
    - 자식 클래스) private 불가능
    - 일반 클래스) private 불가능 (상속 받지 않았으므로 Parent 멤버 쓰려면 객체 만들고 시작해야 함)
  - 다른 패키지
    - 자식) protected, public 가능
    - 일반) public만 가능

- method overriding 시 조건
  - 부모의 제한자 범위와 같거나 넓은 범위로만 사용 가능

### 데이터 은닉과 보호 (Encapsulation)
- 정보 보호 대책
  - 변수는 private 접근으로 막기 -> 공개되는 메서드를 통한 접근 통로 마련 (getter / setter)

#### 객체의 생성 제어와 Singleton 디자인 패턴
- 여러 개의 객체가 필요 없는 경우 : 객체를 구별할 필요가 없는 경우 = 수정 가능한 멤버 변수가 없고 기능만 있는 경우 -> stateless한 클래스
- Singleton 디자인 패턴
  - 생성자의 접근 제한자를 private으로 설정!
  - 외부에서 private member 접근 가능한 getter 생성
  - 객체 없이 외부에서 접근할 수 있도록 getter와 변수에 static 추가

# 📌다형성
- 다형성이란?
  - 하나의 객체가 많은 형(타입)을 가질 수 있는 성질 -> 객체는 하나, 그걸 참조하는 형태는 여러개
  - 상속 관계에 있을 때, 조상 클래스의 타입으로 자식 클래스 객체를 레퍼런스 할 수 있다.
```
public static void main(String[] args) {
  SpiderMan sman = new SpiderMan("피터파커", false);
  SpiderMan sman2 = sman;
  Person person = sman;
  Object obj = person;
}
```
- 다형성의 기능 2가지
  - 1. 다른 타입의 객체를 다루는 배열 -> 다형성으로 다른 타입의 데이터(Person, SpiderMan)를 하나의 배열로 관리 가능
  - 2. 매개변수의 다형성
    - 조상을 파라미터로 처리하여 객체의 타입에 따라 메서드 만들 필요 X, 모든 객체를 처리 가능 O
    - 필요하다면 하위 클래스에서 오버라이딩 필요

# 다형성 활용
### 다형성과 참조형 객체의 형 변환
메모리에 있더라도 참조하는 변수의 타입에 따라 접근할 수 있는 내용이 제한됨
- 자손 타입의 객체를 조상 타입으로 참조 : 형변환 생략 가능
- 조상 타입을 자손 타입으롤 참조 : 형 변환 생략 불가
```java
Phone phone = new Smartphone(); // phone의 타입은 Phone
Smartphone sPhone = (SmartPhone)phone; // phone을 Smartphone에 할당하고자 함 (기능 없을 수도 있을 것 같을 때 명시적으로 형 변환)
```
- 형변환시, 반드시 그 타입을 확인 후 조상을 자손으로 형 변환
  - `instanceof` 연산자 : 실제 메모리에 있는 객체가 특정 클래스 타입인지 boolean으로 리턴

### 참조 변수의 레벨에 따른 객체의 멤버 연결 -> 이게 왜 다형성을 활용한 건지?
- 상속 관계에서 객체의 멤버 변수가 중복
  - 참조 변수의 타입에 따라 연결이 달라짐
- 상속 관계에서 객체의 메서드가 중복될 때 (메서드가 override 됨)
  - 무조건 자식 클래스의 메서드가 호출
  - 최대한 메모리에 생성된 실제 객체에 최적화 된 메서드 동작
- 용도에 따른 적합한 메서드 구성
  - 상위 클래스일수록 활용도 ↑ 복잡성 ↑, 하위 클래스로 갈수록 쓸 수 있는 것까지 사용하지 못하는 경우 발생
  - 비즈니스 로직 상 최상의 객체 사용 권장 (ex. Person)

#### Object - equals
Object가 주소값이 아니라 객체의 내용을 비교할 수 있도록 equals 메서드 재정의

