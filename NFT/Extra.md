# 02.27

## 블록체인

### 블록체인의 분류

- 퍼블릭 : 대표적으로 Ethereum, 누구나 언제든 네트워크에 참여하고 탈퇴가 가능하다.
  - 관련 기술 : Bitcoin, Ethereum, Zcash, Litecoin, ...
- 프라이빗 : 하나의 조직 or 기관이 관장하는 네트워크로 승인된 주체만 자료를 읽고 지정 노드만 거래를 승인한다.
  - 관련 기술 : Quorum, MultiChain, Iroha, Monax, ...
- 컨소시엄 : 이해 관계자 간에 컨소시엄을 구성하여 네트워크를 구성, 네트워크 참여자에 의해 접근 허용한다.
  - 관련 기술 : Hyperledger Fabric, Tendermint, R3 Corda, Private Technologies, ...

### 퍼블릭 네트워크

- 메인넷, 테스트넷으로 구분
  - 메인넷 : 거래소에서 직접 사고 팔 수 있는 이더리움을 거래하고 그 위에서 스마트컨트랙트 등 다양한 Dapp을 개발할 수 있는 네트워크
  - 테스트넷 : 메인넷에 가기 전, 가볍게 시험해볼 수 있도록 이더리움 재단에서 제공하는 네트워크
  - 네트워크마다 네트워크 id가 있어서 id에 맞게 트랜잭션 보낼 수 있음
  - 이더리움넷에서 거래하는 코인과 다른 테스트넷인 곳에서 거래하는 코인은 가치가 매우 다름 -> 별개로 보기

### 프라이빗 네트워크

- 누구나 공개된 Client SW로 나만의 프라이빗 네트워크를 구축 가능
- besu는 엔터프라이즈 환경에 맞게 개량된 Hyperledger의 ethereum 프로젝트

### MetaMask 개념 및 사용법

- 지갑 : 블록체인 네트워크를 사용할 수 있도록 블록체인의 데이터를 생성하거나 거래할 때 서명을 해야 하는데, 이러한 디지털 시그니처는 나의 pc에서만 접근할 수 있도록 계정의 개인키가 생성되어야 하고 이 개인키를 관리하는 프로그램이 '지갑'이다.
- 계정 생성 절차

1. 개인키 : 256bit의 무작위 숫자 -> 64자리의 Hex값으로 인코딩 == 매우 큰 숫자
2. 개인키로부터 공개키 생성
3. 공개키를 hash function 통해서 새로운 값으로 변환
4. 3 결과의 마지막 20바이트에 0x 붙이면 개인 이더리움 계정 주소

#### Provider란?

클라이언트를 통해 이더리움 네트워크에 접근할 수 있도록 제공된 Javascript 객체

1. Ethereum Provider(인스턴스) 확인

- Ethereum Provider API의 페이지 방문 (https://docs.metamask.io/guide/ethereum-provider.html)
- 콘솔창에서 접속되어 있는 ethereum의 정보, 오브젝트를 확인할 수 있음

2. 연결 상태 확인
   `ethereum.isConnected()`
3. 이더리움 계정(지갑) 활성화 API
   `ethereum.enable()` : 사용할 지갑을 선택해서 계정에 연결하여 api가 지갑에 연결되어 있음을 설정할 수 있음
4. 활성화된 계정 확인
   `ethereum.selectedAddress` : 지갑 주소 변수 확인
5. Ethereum Provider로 RPC API 보내기 / 이더리움 네트워크에 직접 요청 보내기 -> 직접 RPC(Remote Procedure Call)를 콜
   `ethereum.request()`

- #### RPC란?
  > 별도의 원격 제어를 위한 코딩 없이 다른 주소 공간에서 리모트의 함수나 프로시저를 실행 할 수 있게 해주는 프로세스간 통신
- API 문서
  https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getbalance

- #### 이더리움의 sign이란?
  이더리움에서의 트랜잭션의 종류
  - 암호화폐 송금
  - 컨트랙트 배포
  - 컨트랙트 호출

#### 이더리움 트랜잭션 담기는 정보 구조

| 항목               | 내용                                                       |
| ------------------ | ---------------------------------------------------------- |
| nonce              | 계정에서 발생시킨 트랜잭션의 누계                          |
| gasPrice, gasLimit | 트랜잭션을 실행할 때 지불해야 하는 가스 비용 정보          |
| to                 | 트랜잭션 수신 계정의 주소                                  |
| value              | 송금되는 ETH 금액(암호화폐를 송금할 때 사용)               |
| v, r, s            | 타원곡선암호(ECDSA)를 사용하는 송신 계정의 전자서명        |
| init               | 스마트 컨트랙트 코드(스마트 컨트랙트를 배포할 때 사용)     |
| data               | 스마트 컨트랙트 파라미터(스마트 컨트랙트를 실행할 때 사용) |

---

# 02.28

## 블록체인과 백엔드

---

# 03.02

---

# 03.03

### 스마트 컨트랙트

### Solidity

### ERC721

> 증서라고 알려진 NFT의 표준안으로서, 이더리움 네트워크에서 대체 불가능하다는 NFT의 개념이 도입된 토큰

#### ERC의 개념

> 'Ethereum Request for Comment'의 약자로, 이더리움 네트워크에서 토큰을 만들 때 따라야 하는 프로토콜

#### ERC-20 vs ERC-721

- ERC-20이란?
  - 많은 프로토콜 중에서 20번째 프로토콜을 의미하며, 이더리움 네트워크에서 생성된 대부분의 토큰들은 ERC-20를 기반으로 생성되었다.
  - 특징
    - 동등한 가치로 구매, 판매, 교환
    - 누가 토큰을 가지고 있는지 상관없이 동일한 가치를 지님 -> 일반적인 화폐와 같은 개념. 즉, 다른 사람이 가진 같은 토큰은 동일한 가치를 지닌다.
- ERC-20와 다른 ERC-721의 특징
  - ERC-20은 대체 가능하지만 ERC-721은 대체불가능하다.
  - 같은 데이터라도 데이터가 만들어지는 과정이 ERC-721 토큰을 만드는 과정에 해당하며, 다른 데이터와 가치가 다른 thing이다.
  - 부분적인 소유권이 허용되며 교환될 수 있다.

### ERC-721 토큰을 활용한 사례

제품에 ERC-721 토큰의 개념이 도입될 수 있으며, 제품에 대한 소유권은 온라인으로 거래될 수 있으므로 이를 기반한 활용 방안은 다양하다. 대표적으로, 게임 CryptoKitties가 있다. 고양이를 수집하고 번식시켜 희귀한 고양이를 생성시킬 수 있고 이를 높은 가로 거래하여 교환할 수도 있다.

### 프로젝트에 활용될 ERC

오픈제플린을 통해 ERC-721 기반 프로젝트를 구현할 수 있다.

#### ERC-721의 인터페이스

- IERC721 : 모든 ERC-721 호환에 필요한 인터페이스
- IERC721Receiver : 지갑/매매/시장 어플에서 `safeTransferFrom`을 사용 시 필수적으로 구현해야 하는 인터페이스
- IERC721Metadata : 선택적으로 메타데이터를 추가할 수 있음 (이름, 기호, 토큰 등)
- IERC721Enumerable : 온체인 토큰을 열거하기 위한 선택적인 인터페이스로 가스비가 많이 소요됨

- 오픈 제플린에서 제공하는 구현체 3가지
  - ERC721: 핵심 구현 with URI 메커니즘
  - ERCEnumerable: 열거 기능을 위한 확장
  - ERC721Holder: Reciever 구현

#### ERC-165

- ERC-165 : 인터페이스 확인 구현 후 스마트 컨트랙트에 주어진 인터페이스를 구현했는지 여부, 언제 사용하는지 감지
  - etherscan.io에서 확인할 수 있는데도 ERC-165를 쓰는 이유?
    - etherscan.io에서 확인할 수 있는 정보는 onchain이지만, 해당 정보를 보여주는 etherscan.io는 offchain이다. 이러한 서비스가 없어도 스마트 컨트랙트는 사용될 수 있고, 그래야 하므로 oncahin 방식으로 특정 인터페이스를 정의했는지 확인하는 기능이 필요하다.

### 가나슈

### 트러플

### IPFS
