# OSIV와 성능 최적화

- OSIV(Open Session In View)
- 트래픽이 많은 서비스에서 장애를 막을 수 있으려면 알아야 할 개념
- JPA가 언제 데이터베이스 커넥션을 가지고 오고, 언제 DB에 반환하는가에 대한 문제이다.

  - JPA는 영속성 컨텍스트 안에는 동작하려면 데이터베이스 커넥션과 긴밀하게 연결되어 있다.
  - DB 트랜잭션이 실행될 때, 영속성 컨텍스트가 DB 커넥션을 가져옴
  - 서비스 계층에서 T 시작할 때 DB 커넥션을 가져오고, 언제 DB에 돌려주냐면. 다 하고 나가고 나서도 반환하지 않는다.
  - 유저한테 API가 반환될 때까지 데이터베이스 커넥션과 영속성 컨텍스트가 계속 살아있음, 완전히 response 나갈 때까지. -> 그래서 api 컨트롤러에서 지연 로딩이 가능했던 것!
  - 단점은? 오랜시간동안 DB 커넥션을 물고 있어서, 실시간 트래픽이 중요하다면 커넥션이 모자라서 장애 발생 가능성 O 중간에 대기 시간이 있으면 커넥션 리소스 반호나하지 못해서 병목 현상 발생 가능 O

- OSIV OFF 가능
  - Service -> Repository의 트랜잭션 범위에서만 영속성 컨텍스트가 살아있도록 함
  - ex. 멤버 join해서 영속성 컨텍스트 만들어지면, 이 로직이 끝나면 영속성 커넥션 날라가고, DB 커넥션도 반환 다 해버림 -> join에서 돌아간 시점은 둘 다 안 써서 어떤 로직을 써도 트래픽 많거나, 사용자 요청 많은 경우에는 커넥션을 유연하게 활용 가능
  - 단점
    - 지연로딩은 영속성 컨텍스트가 살아있을 동안 활용할 수 있으므로 트랜잭션 안에서 지연로딩을 처리해야 한다. -> 즉, Controller에서 해준 지연로딩 처리가 불가능해지는 것. 서비스 계층에서 다 로딩이 된 걸 가져와야 함.
  - `could not initilize proxy` 에러
    - member가 proxy인데 이걸 초기화하는 과정에서 터져버림.
      - getName 호출되는 순간, 영속성 컨텍스트를 통해서 proxy 초기화를 해야 하는데 여기서 controller에서 영속성 컨텍스트 없어서 터짐.
    - 해결 : 페치 조인, 트랜잭션 안에서 로딩 다 하기, OSIV true로 켜기

### 문제 해결

- service 단에서 query 패키지를 만들고 메인 비즈니스 기능 외의 변환 기능 `OrderQueryService`를 넣어준다.
  - `@Transactional
(readOnly = true)` 어노테이션 처리
  - DTO로 다 들고와서 여기서 다 해주고, controller에서는 service.변환함수이름으로 실행만 해줌
