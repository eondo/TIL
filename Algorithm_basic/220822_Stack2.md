- Introduction
  - 계산기 1
  - 계산기 2
  - 백트래킹
  - [참고] 부분집합, 순열

## Stack 2

### 계산기 1
수식 연산 자체를 스택을 이용해서 해보자

중위표기식의 후의표기식 변환 방법

- 중위 표기법에서 후위 표기법으로의 변환 알고리즘(스택 이용)2

### 계산기 2
- 후위 표기법의 수식을 스택을 이용하여 계산해보자

### 백트래킹
해를 찾는 도중에 '막히면'(즉, 해가 아니면) 되돌아가서 다시 해를 찾아 가는 기법
- 백트래킹 기법은 최적화 문제와 결정 문제를 해결 가능
- 결정 문제 : 문제의 조건을 만족하는 해가 존재하는지의 여부를 yes or no로 답하는 문제
  - 미로 찾기
  - n-Queenn 문제
  - Map coloring
  - 부분 집합의 합(Subset Sum) 문제 등


내가 갈 수 있는 목록 후보군을 만들어놓고 거기를 반복적으로 방문
가능한 갈 수 있는 모든 곳을 다 감 : DFS
굳이 여긴 안 가도 되겠다 싶어서 예측 가능한 정도로 후보군들을 방문하는 것 : 백트래킹

DFS 쓰기에 경우의 수가 너무 많은 경우 N! -> 백트래킹 이용하여 풀어야 할 수 있음
좀 더 정확히 얘기하면 상태공간 트리의 탐색 방법으로 DFS를 적용한다고 볼 수 있습니다.

- 절차
  - 상태 공간 트리의 DFS을 실시한다
  - 각 노드가 유망한지를 점검한다.
  - 만일 그 노드가 유망하지 않으면, 그 노드의 부모 노드로 돌아가서 검색을 계속한다.
  
- 문제
2. 부분집합 구하기
후보군을 추천하는 과정과, 추천받은 후보군에서 반복문으로 가져다 쓰는 형식이 존재
기본 틀 존재하고, 원하는 작업 / 후보군 추천하는 함수 2가지의 형식만 문제에 맞게 바꿔서 쓸 수 있음

- 연습문제 2
  - 1이 포함된 경우 / 1이 포함되지 않는 경우
  - (+) i번 원소의 포함 여부를 결정하면 i까지의 부분집합의 합 si를을 매번 계산하면 가지치기를 할 수 있겠다!
  - 전까진 i에 대해서 결정하는 단계라고 했을 때, 아깐 f(i, N)까지만 봤는데 이젠 f(i, N, s, t) (=i-N까지의 합)을 본다

이 개념이 쓰이는 문제 유형이 크게 3가지? 이 부분 못 들음

### 순열
크게 3가지 방법, 내가 하고자 하는 목적 잘 알고 이해하자
처음에 넣어 놓고 시작해서, P[0] 결정할 때, 나 원래 숫자로 유지할래 ->...-> 원상복구! P[0] 결정할 때 나 오른쪽 거랑 바꿔볼래 ->... 돌아오자 -> 원상복구! P[0] 이젠 마지막 거랑 바꿔볼래 -> ...

- 문제의 형태
  - 순서의 비용 달라지는 문제
  - 일을 맡은 사람마다 다른 시간이 걸리는데 어떤 사람-일 조합이 최소 비용인가 찾는 문제