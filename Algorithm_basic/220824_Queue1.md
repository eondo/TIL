## Queue


- 선형 큐 이용시의 문제점
  - 원소의 삽입과 삭제를 계속할 경우, 배열의 앞부분에 활용할수 있는 공간이 있음에도
- 해결방법
  - 1차원 배열을 사용하되, 논리적으로는 배열의 처음과 끝이 연결되어 원형 형태의 큐를 이룬다고 가정하고 사용


- append, pop(0) 로 구현하는 큐는 매번 그만큼의 새로운 리스트를 가리키는데, from collections import deque를 써서 q.popleft() 를 쓰면 그냥 하나의 리스트 안에서 front, rear가 이동되는 방식이다

#### 원형 큐의 구조
초기 공백 상태 : front = rear = 0
한 칸을 비워두고 계산을 조금 간단하게 하는 방식으로 가자

- Index의 순환
  - front, rear의 위치가 배열의 마지막 인덱스인 n-1를 가리킨 후, 처음으로 돌아감 -> 나머지 연산자 사용

- front 변수
  - 공백 상태와 포화 상태를 구분을 쉽게 하기 위해 front가 있는 자리는 사용하지 않고 항상 빈자리로 둠

- 삽입 위치 및 삭제 위치

#### 원형 큐의 구현
- 초기 공백 큐 생성
  - 크기 n인 일차원 배열 생성
  - front, rear = 0 초기화
- 
- 공백 :front == rear
- 포화 : (rear + 1) % len(Cq) = rear

- 원형 큐 : 덮어써버리는 구조, 덮고 지나가버려도 되는, 그 전 거는 온전히 갖고 있지 않아도 되는 데이터의 경우에 사용 가능, 과거의 데이터는 필요 없을 때! -> 문제 풀이에서는 선형 큐를 쓰자!

- 크기를 어떻게 정해줄 것인가, 과거 데이터는 덮어쓸 것인가? 정해야 함

큐가 비어있지 않으면 꺼내!로 문제풀이땐 작성

한 칸 빼놓고 공간을 계속 이용할 순 있지만 원래 있던 빈칸이 나중엔 채워지고, 그리고 심지어 덮어써지기도 하기 때문에 문제 풀이에 사용할 때 규칙을 정하고 사용해야 함

### 우선순위 큐
우선순위를 가진 항목들을 저장하는 큐
FIFO 순서가 아니라 우선순위가 높은 순서대로 먼저 나가게 됨

- 문제점 : 배열을 사용하므로, 삽입이나 삭제 연산이 일어날 때 원소의 재배치 발생으로 소요되는 시간, 메모리 낭비 존재 -> 배열 + 트리 구조 함께 사용!

### 큐의 활용 : 버퍼(Buffer)
데이터를 한 곳에서 다른 한 곳으로 전송하는 동안 일시적으로 그 데이터를 보관하는 메모리의 영역
- 버퍼의 자료 구조
  - 순서대로 입력/출력/전달되어야 하므로 FIFO 방식의 자료구조 큐가 쓰임

- 마이쮸 문제
  - Queue_실습에 저장함

## BFS
- 그래프를 탐색하는 방법에는 크게 두 가지 : 깊이 우선 탐색, 너비 우선 탐색
미로, 그래프 : A -> B로 가는 경로가 있는가? DFS, BFS 모두 가능
A -> B로 가는 경로의 개수는? DFS 사용
A -> B로 가는 경로 중 최단 경로의 길이는? 둘 다 가능하지만 주로 BFS 사용

- BFS는 반복 구조로 구현 가능 / DFS는 재귀, 반복 구조
- 탐색 시작점의 인접한 정점들을 먼저 모두 차례로 방문한 후에, 방문했던 정점을 시작점으로 하여 다시 인접한 정점들을 차례로 방문하는 방식

기본형이라서 중복으로 들어가게 괜찮게 해놔도 괜찮을 수 있지만, 뭘 기준으로 중복을 방지할 거냐에 따라 다를 수 있음. 교재 코드는 먼저 visited 확인하는 걸 중복적으로 일어나는데 다르게 할 수 있음. 즉, queue,append(i)에 적어주고 바로 뒤에 visited를 확인하는 방법!
-> 중복으로 visited 검사하는데 이걸 바꿔줄 수 있는 방법 : visited를 이름 올리신 적 있어요? 있으면 다시 올리지 마세요로 바꾸자! 검사했다 표시 말고 이름을 올린 적 있다고 표시로 하자! -> 중복을 없애면 queue의 사이즈가 정점의 수만큼만 queue 사이즈를 정해주기 편하고, 인접 정점 말고 처음 들어오는 애 부분의 if not visited[t]가 필요 없어짐 -> append와 visited 표기를 묶어서 해주기! 


### [참고] BFS 예제
visited[i] 값을 자기 상위 인덱스의 visited값에서 +1한 값들로 채워줌
visited = [1, 2, 2, 2, 3, 3, 3, 3, 3] 이 되고 같은 숫자를 가지는 애들끼리
같은 우선순위를 가지는 애들을 알 수 있음!
- 응용 사례
-> BFS 사용 경우가 최단거리 찾는 경우가 많은데 이때 3인 숫자를 보면 두 번의 엣지를 거쳐왔구나 지나온 거리를 알 수 있음
-> 그래프를 주고 A로부터 거리가 같은 정점은 최대 몇 개인가? 문제에서 유용
-> 비상연락망 문제

- BFS 특징 : 출발점이 한 개 x, 여러개인 탐색의 경우도 가능