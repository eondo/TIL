### 알고리즘
APS 과정의 목표 중 하나 : 보다 좋은 알고리즘을 이해하고 활용하는 것
- 정확성 
- 작업량
- 메모리 사용량
- 단순성
- 최적성

알고리즘의 작업량 => 시간복잡도 (실행되는 명령문(연산)의 개수를 계산)

### 배열
일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조
메모리에 여러 '연속적으로' 칸을 두고 하나의 묶음으로 저장하는 방식

- 배열의 필요성
#### 1차원 배열
- 선언
비어있는 배열을 만들어야 하는 상황인데 10칸으로 만들어야 할 때 값을 구체적으로 정하지 않은 숫자로 배열 생성, Arr = [0] * 10
- 접근  
index로 접근

#### 예제
- maxV = float(-'inf')는 느리다?
- max 구할 때, 초기값을 0보다는 index 0의 값이나 조건에 따라 다르게 효율적으로 생각할 수 있어야 함
- 예제 : 각 원소에 대해 오른쪽에 있는 원소 중 더 작은 원소의 개수 구하기

### 정렬
- 키 : 자료를 정렬하는 기준이 되는 특정 값

#### 정렬의 종류
- 대표적인 정렬 방식의 종류(1~4까지는 직접 코드로 짤 수 있을 정도까지 도달해야 함)
  - 버블 정렬
  - 카운팅 정렬
  - 선택 정렬
  - 퀵 정렬
  - 삽입 정렬
  - 병합 정렬
---
#### 1. 버블 정렬
#### [55, 7, 78, 12, 42]를 버블 정렬하는 과정(오름차순) O(n2)
  - 첫 번째 패스 -> 가장 오른쪽에 현재 주어진 영역에서 주어진 가장 큰 수가 위치
  - ...
  - 패스 반복할 때마다 구간이 줄어듦
  - 모든 작업을 반복할 때마다 구간의 '시작'과 '끝'은?
    - 0 ~ N-1
    - 0 ~ N-2
    - ...
    - 0 ~ 1 (0이어도 무방)
  - 구간의 끝을 i라고 했을 때, for i : N-1 -> 1
  - 인접한 원소 중 왼쪽 인덱스를 j라고 했을 때, for j: 0 -> j-1 
  - 왼쪽이 크면, if arr[j] > arr[j+1]
  - 둘이 자리를 바꿈, arr[j] <-> arr[j+1]
---
#### 2. 카운팅 정렬
항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘

- 제한 사항
  - 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능 : 각 항목의 '발생 회수'를 기록하기 위해, 정수 항목으로 인덱스 되는 카운트들의 배열을 사용하기 때문
  - 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 함

- 시간 복잡도
  - O(n + k)

#### [0, 4, 1, 3, 1, 2, 4, 1]을 카운팅 정렬하는 과정
- 1단계) 개수 알아내기
  - Data에서 각 항목들의 발생 회수를 세고, 정수 항목들로 직접 인덱스 되는 카운트 배열 cnt에 저장함
  ```
  for i in range(N):
      cnt[arr[i]] += 1
  ```
  - 정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 counts의 원소를 조정함
  ```
  for i : 1 -> N-1
      counts[:] = counts[i-1] + counts[i]
  
  ## 누적 개수를 구해서 2~4 원소는 총 몇 개인지 쉽게 알 수 있음
  ```
  + 이때, 세그먼트 트리? 말이 나왔는데 나중에 알아보기!

- 2단계
  - counts[1]을 감소시키고 temp에 1을 삽입함
  - 0과 1 합쳤을 때 4개랬는데, 마지막 읽으니까 1이더라. 그럼 count[1]을 하나 감소시키고 temp에 1을 복사해놓자.
  - 뒤에서 2번째 거를 보면 4고 4는 8이라 되어있으니까 index(8-1)에 걔를 넣는다
  - 이때 오른쪽부터 넣는 이유는 앞의 4와의 순서를 유지하게 만들기 위해서 stable sort!
  - Q. ​counts배열에 누적 갯수가 아니라 해당 수의 갯수만 저장하고 결과배열을 만들때 앞에서부터 갯수만큼 채워나가는 방법이 더 빠르지 않나요?
  - A. 가능은 하나, 안정적인 정렬은 아니다. Data가 만약 (a. b)로 어떤 쌍으로 이뤄진 거에서 a는 같아서 b의 값이 다르면 이 둘의 앞뒤 순서, 즉, 원래 순서를 유지한 채로 정렬하려면 이것까지 만족하는 정렬을 위한 것이기 때문.

#### 카운팅 정렬 알고리즘
```python
def Counting_Sort(A, B, k)

for i in range(len(B)~) ## 전까지 쓰는 용도도 있음, 그리고 얘 영역 수행시간 n번. 
```
#### Baby-gin Game
- 1. c.f. 완전 검색(Exaustive Search)
  - 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법
  - Brute-force 혹은 generate-and-test 기법이라고도 불림
  - 모든 경우의 수를 테스트한 후, 최종 해법을 도출함
  - 일반적으로 경우의 수가 상대적으로 작을 때 유리함
  - 자격검정평가 때, 우선 완전 검색으로 접근하여 해답을 도출한 후, 성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확인하는 게 바람직함

- 고려할 수 있는 모든 경우의 수 생성 -> 모든 경우의 순열 나열
- 순열
  ```python
  # {1, 2, 3}을 포함하는 모든 순열을 생성하는 함수
  for i1 in range(1, 4):
      for i2 in range(1, 4):
          if i2 != i1:
              for i3 in range(1, 4):
                  if i3 != i1 and i3 != i2:
                      print(i1, i2, i3)
  ```
- 2. c.f. 탐욕(Greedy) 알고리즘
- 완전 검색처럼 다 돌리는 것 대신에 적당히 돌리는 것은 없을까?
- 최적해를 구하는 데 사용되는 근시안적인 방법
- 동작 과정
  - 1) 해 선택
  - 2) 실행 가능성 검사
  - 3) 해 검사

Baby-gin을 완전검색 아닌 방법으로 풀어보자
- 6개 숫자는 6자리 정수 값으로 입력
- counts 배열의 각 원소를 체크하여 run, triplet 및 baby-gin 여부를 판단

- 풀이
```python
# 1) input 넣고 c 리스트 완성
num = 456789
c = [0] * 12 ## 0~9인데 왜 12일까? 여분 2개를 만듦 -> triplet, run 조사할 때 index 변수를 따로, 조건문을 줘야 하는데 그럴 필요 없게 하려고 그냥 잉여 칸을 붙여둔다

for i in range(6): ## 6자리 숫자니까! (* + 참고) 
    c[num % 10] += 1
    num //= 10
```

```python
# 2) run, triplet 조사, 각 조사 후 데이터 삭제
## triple, run 발견하고 같은 자리로 다시 돌아오기 때문에 놓치지 X

```

```python
# + 많이 쓰이는 상황, 자릿수가 정해지지 않은 가변형의 경우라면 
while num > 0:
    c[num % 10] += 1
    num //= 10 ## 끝에 거 자르기
```