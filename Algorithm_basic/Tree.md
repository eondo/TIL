# Tree

### INDEX
- 트리
- 이진 트리
- 이진 트리의 표현
- [참고] 이진 트리의 저장
- 연습 문제
- 이진탐색 트리
- 힙
<br>

## 트리
🧷 트리의 개념
- 비선형 구조
- 원소들 간에 1:n 관계를 가지는 자료구조, 계층형 자료구조로 상위 원소에서 하위 원소로 내려가면서 확장되는 구조

🧷 트리의 조건
  - 노드 중 최상위 노드 : 루트(root)
  - 나머지 노드들의 분리 집합 T1, T2, ... TN은 각각 하나의 트리가 되며(재귀적 정의) 루트의 부 트리가 됨

🧷 트리의 용어
  - 노드 : 트리의 원소
  - 간선 : 노드를 연결하는 선으로 부모 노드와 자식 노드를 연결
  - 루트 노드 : 트리의 시작 노드
  - 형제 노드 : 같은 부모 노드의 자식 노드들
  - 조상 노드 : 간선을 따라 루트 노드까지 이르는 경로에 있는 모든 노드들
  - 서브 트리 : 부모 노드와 연결된 간선을 끊었을 때 생성되는 트리
  - 자손 노드 : 서브 트리에 있는 하위 레벨의 노드들

🧷 차수와 높이
- 차수
  - 노드의 차수 : 노드에 연결된 자식 노드의 수
  - 트리의 차수 : 트리에 있는 노드 중 차수 중에서가장 큰 값
  - 단말 노드(리픝 노드) : 차수가 0인 노드, 자식 노드가 없는 노드

- 높이
  - 노드의 높이 : 루트에서 노드에 이르는 간선의 수. 노드의 레벨
  - 트리의 높이 : 트리에 있는 노드의 높이 중에서 가장 큰 값. 최대 레벨

❓ __How to apply__\
상황을 정리해보니 트리 모양이 되는 상황 or 함수들의 호출 단계를 나타냈을 때 트리가 된다면?\
→ 트리의 접근 방법으로 문제를 해결하도록 한다.
<br>

## 이진트리
모든 노드들이 2개의 서브트리를 갖는 특별한 형태의 트리로 각 노드가 자식 노드를 최대한 2개까지만 가질 수 있는 트리
#### 🧷 이진트리의 특성
- 레벨 i에서의 노드의 최대 개수는 2^i개
- 높이가 h인 이진 트리가 가질 수 있는 노드의 최소 개수는 (h + 1), 최대 개수는 (2^(h + 1) - 1)개
  
#### 🧷 이진트리의 종류
❗ 종류에 따라 값에 접근하는 방식, 저장하는 방식이 달라짐
1. __포화 이진 트리(Full Binary Tree)__
- 모든 레벨에 노드가 포화상태로 차있는 이진 트리
- 루트를 1번으로 하여 아래로 가면서 왼 -> 오 방향으로 번호를 붙임, (2^(h + 1) - 1)까지 정해진 위치에 대한 노드 번호를 가짐

2. __완전 이진 트리(Complete Binary Tree)__
- 높이가 h이고 노드 수가 n개일 때 포화 이진 트리의 노드 번호 1번부터 n번까지 빈 자리가 없는 이진 트리
- 1 ~ n번까지 연속적으로 다 있어야 함 == 즉, 중간에 빠진 정점이 있으면 안 됨

3. __편향 이진트리(Skewed Binary Tree)__
- 높이 h에 대한 최소 개수의 노드를 가지면서 한쪽 방향의 자식 노드만을 가지는 트리
<br>

## 📌 이진트리의 순회(traversal)
트리의 각 노드를 중복되지 않게 전부 방문하는 것이 순회이며, 트리는 비선형 구조이기 때문에 선형구조에서와 같이 선후 연결 관계를 알 수 없음

🧷 트리의 특별한 순회 방식 → 전위 순회, 중위 순회, 후위 순회

- 순회란?
  - 트리의 노드들을 체계적으로 방문하는 것

- 기본적인 3가지 순회 방법
  - __전위 순회(preorder)__\
    : 부모노드 방문 후, 자식노드를 좌, 우 순서로 방문

  - __중위 순회__\
    : 왼쪽 자식, 부모, 오른쪽 자식 노드 순으로 방문
  
  - __후위 순회__\
    : 자식노드를 좌우 순서로 방문한 후 부모노드로 방문

### 1️⃣ 전위 순회
- 수행 방법
1) 현재 노드 n을 방문하여 처리 → V
2) 현재 노드 n의 왼쪽 서브트리로 이동 → L
3) 현재 노드 n의 오른쪽 서브트리로 이동 → R

```python
def preorder(n):    # 전위 순회
    if n:
        print(n)    # visit(n)
        preorder(ch1[n])
        preorder(ch2[n])
```

### 2️⃣ 중위 순회
- 수행 방법
1) 현재 노드 n의 왼쪽 서브트리로 이동 → L
2) 현재 노드 n을 방문하여 처리 → V
3) 현재 노드 n의 오른쪽 서브트리로 이동 → R

```python
def inorder(n):     # 중위 순회
    if n:
        inorder(ch1[n])
        print(n)    # visit(n)
        inorder(ch2[n])
```

- 과정 상세 설명
1) 처음 루트에 접근하면 루트를 처리하지는 않고 지나만 가고 현재 노드 n의 왼쪽 서브트리로 이동
2) 이런 식으로 어떤 정점에 접근하는데 그게 존재하면? **(방문보다는 처리라는 표현이 정확함)**
3) 일단 왼쪽 자식노드로 가봄, 이때 그 왼쪽에도 왼쪽 자식을 가지는 경우 재귀적으로 왼쪽으로 가는 함수를 호출
4) 왼쪽 서브트리 다 방문하면 이제 return → visit(T)를 처리함
5) 오른쪽으로 가는데 없으면 return, 그리고 이전 단계로 return하고 마지막 루트노드를 방문
- __왼쪽에서 return__ 해서 온 거면, 왼쪽 다 순회했다는 거니까 __해당 부모 루트를 방문 처리함__
- 오른쪽에서 return해서 온 거면, 처리 없이 이전 단계로 올라감

### 3️⃣ 후위 순회
- 수행 방법
1) 현재 노드 n의 왼쪽 서브트리로 이동 → L
2) 현재 노드 n의 오른쪽 서브트리로 이동 → R
3) 현재 노드 n을 방문하여 처리 → V

```python
def postorder(n):   # 후위 순회
    if n:
        postorder(ch1[n])
        postorder(ch2[n])
        print(n)
```

- 과정 상세 설명
1) 루트를 만나면 왼쪽 서브트리로 이동을 반복
2) 왼쪽 서브트리가 없는 상태까지 오면 return해서 오른쪽을 보고 없으면 또 return
3) 오른쪽에서 return해 오면 해당 노드를 방문 처리
<br>

## 📌 이진트리의 표현 (저장 방법)

### 배열을 이용한 이진트리의 표현
❗ 포화이진트리 & 완전이진트리(에 한한)의 저장 방법

- 루트의 번호를 1, 나머지 노드들에 대하여 번호를 차례로 부여
- 노드에 무엇이 저장되어 있는지까지는 신경쓰지 않고, 우선 연결 관계만 알고 잘 따라가는 것에 집중
- 배열을 이용하여 마지막 정점까지 번호를 인덱스로 하는 n + 1칸의 배열을 만듦\
  ex. tree[0], ... tree[13] → 포화/완전 이진트리의 저장 방법

- 노드 번호의 규칙 → 코드에 사용 가능
  - 노드 번호가 i인 노드의 부모 노드 번호 : floor(i/2), i // 2
  - 노드 번호가 i인 노드의 왼쪽 자식 노드 번호 : 2 * i
  - 오른쪽 자식 노드 번호 : 2 * i + 1
  - 레벨 n의 노드 번호 시작 번호 : 2 ^ n

[참고] 이진 트리의 저장 - *포화/완전 이진트리가 아닌 경우 사용 가능*
1. 부모 번호를 인덱스로 자식 번호를 저장 → 목적 : 순회
- 순회를 할 때에는 부모를 기준으로 자식 번호가 필요하므로 부모를 인덱스로 자식 번호 저장
2. 자식 번호를 인덱스로 부모 번호를 저장 → 목적 : 조상을 찾거나, 루트를 찾을 때
```python
# 1. 부모를 인덱스로 자식 번호 저장
ch1 = [0] * (V + 1)
ch2 = [0] * (V + 1)

# 2. 자식을 인덱스로 부모 번호 저장
par = [0] * (V + 1)

for i in range(E):
    p, c = arr[i * 2], arr[i * 2 + 1]

    # 1.
    if ch1[p] == 0:     # 아직 자식이 없으면
        ch1[p] = c      # 자식1로 저장
    else:
        ch2[p] = c

    # 2.
    par[c] = p
```
__[practice]__ 루트를 찾는 함수 find_root()
```python
def find_root(V):      # 루트 찾기
    for i in range(1, V + 1):
        if par[i] == 0: # 부모가 없으면
            return i

root = find_root(V)
```
__[practice]__ 특정 정점의 자손 개수를 구하는 함수 f()
- 순회 → 서브트리의 정점 개수 세기 → 개수 - 1
```python
def f(n):       # global cnt 없이 순회한 정점 수를 리턴하는 함수
    if n == 0:  # 서브트리가 비어있으면(없는 자식이면)
        return 0
    else:
        L = f(ch1[n])
        R = f(ch2[n])
        return L + R + 1
```

__단점__
- 편향 이진트리 등의 경우 메모리 공간 낭비가 발생할 수 있음
- 트리의 중간에 새로운 노드를 삽입/기존의 노드를 삭제할 경우 배열의 크기 변경 어려움 → 그러나 고려하지 않고 문제 풀이 시 배열을 이용해서 이진 트리 표현!

### 트리의 표현 - 연결리스트
- 연결 자료구조를 이용한 이진트리의 표현
- 따로 '파이썬 자료구조' 시중 책을 통해 학습하도록 함

❗ __Think__\
실제 순회를 응용할 땐 → 전위, 후위를 섞어서 코드를 만들다거나 하는 응용, 비어있는 트리 순회하면서 전위순회로 값 채우기, 후회순회로 return값 받아서 저장된 값을 활용하는 등의 응용 가능

### 수식 트리
- 수식을 표현하는 이진 트리
- 연산자 → 루트 노드 or 가지 노드
- 피연산자 → 잎 노드
<br>

## 📌 이진탐색 트리
❗ 자료구조, 알고리즘 책을 보면 이진트리에 대한 복잡한 알고리즘 설명, 이진트리를 균형있게 유지하는 여러가지 알고리즘들을 찾아볼 수 있음\

- 탐색 작업을 효율적으로 하기 위한 자료 구조
- 모든 원소는 서로 다른 유일한 키를 가짐
- 배치 : key(왼쪽 서브트리) < key(루트 노드) < key(오른쪽 서브트리)
- 재귀적인 구조로서 왼쪽 서브트리와 오른쪽 서브트리도 이진 탐색 트리임
- 삽입/삭제가 빈번하다면 이진 탐색 트리를 만들어둔다면 정렬을 매번 할 필요 없이 순회만 하면 정렬되 값을 얻을 수 있음
  - 중위 순회하면 오름차순으로 정렬된 값을 얻을 수 있음\
  - 🚫 __주의__ - 루트값을 잘못 설정하면, 루트의 왼오 중 한쪽만 깊어지는 구조가 되어 트리 구조에서 비효율적

### 1. 탐색 연산
### 2. 삽입 연산
1. 먼저 탐색 연산을 수행
2. 탐색에서 탐색 실패가 결정되는 위치에 원소를 삽입

__이진 탐색 트리 - 성능__\
탐색, 삽입, 삭제 시간은 트리의 높이만큼 시간이 걸림 : O(h), h : BST의 높이
- 평균의 경우 : O(log n)
- 최악의 경우 : O(n)

❓ __탐색 연산 vs 순회__\
- 차이점 : 순회는 재귀 형태를 이용해서 되돌아오고, 탐색 연산은 굳이 재귀를 할 필요 없음. 탐색 연산은 둘 중 한 쪽만 선택해서 가고, 찾거나 실패하면 끝내면 돼서 굳이 리턴해서 같은 경로로 돌아올 필요가 없기 때문. 즉, 트리에서의 탐색이 반드시 재귀일 필요 없고, 반복 구조로도 구현 가능함!

- 검색 알고리즘의 비교, 이러한 차이점이 있다 정도만 알고 넘어가기, 균형트리의 예시 : Red-Black Tree 언급
- 상용에서 검색을 위해 어떤 알고리즘을 사용할까?

### 3. 삭제 연산
- 13(리프 노드) 삭제하는 경우
  - 13을 탐색 연산으로 찾고 자식 없어서 그냥 지움 
- 12(중앙에 끼인 노드) 삭제하는 경우
  - 9에서 12로 내려가고, 타고 15까지 내려갔을 때 9와 15을 잇고 12를 날림
- 9(루트노드) 삭제하는 경우
  - 왼쪽 서브트리에서 가장 큰 값을 찾아서(왼쪽 서브트리에서 중위 순회해서 맨 마지막으로 나오는 값) 그것을 루트노드 원래 자리에 옮겨놓고 원래의 왼쪽 최대값을 날림
<br>

## 힙(heap)
**완전 이진 트리**에 있는 노드 중에서 키값이 가장 큰 노드나 키값이 가장 작은 노드를 찾기 위해서 만든 자료구조
[+] 연결리스트 쓸 때, 프로그램이 실행되는 중에 사용하는 메모리의 양, 크기가 변할 수 있는 경우에 사용하는 메모리 공간을 힙이라고도 함
❗ 배열의 인덱스 연산 연습하는 용도로 접근하면 좋을 것

#### - 최대 힙
- 키값이 가장 큰 노드를 찾기 위한 완전 이진 트리
- 부모노드의 키값 > 자식노드의 키값
#### - 최소 힙
- 키값이 가장 작은 노드를 찾기 위한 완전 이진 트리
- 부모노드의 키값 < 자식노드의 키값

### 힙 연산 - 삽입
__<최대 힙에서의 삽입 연산>__
- 17 삽입\
마지막 정점 번호 현재 6\
첫번째 조건 : 완전이진트리 +
last + 1하고 거기에 17 넣고 2) 부모보다 작은지 확인 → 만족하면 끝
- 23 삽입\
조건에서 부모가 더 작아지는 상황 발생 → 자리 바꿈 → 조건이 다 만족할 때까지 자리 바꿈\
즉, 삽입했는데 조건을 만족하지 않으면 부모가 더 이상 없거나, 부모 > 자식 조건을 만족할 때까지 자리 바꿈\
→ 따라서 재귀(X), 인덱스 연산일 뿐(O)

```python
def enq(n):
    global last
    last += 1   #1st 완전이진트리에서 마지막 정점을 하나 추가해서 완전이진트리 유지해!
    heap[last] = n  # 마지막 정점에 key 추가
    # 부모가 있고, 부모 < 자식인 경우 자리 교환 (부모가 없거나, 부모 > 자식 조건을 만족할 때까지)
    c = last
    p = c // 2  #완전이진트리에서 부모 정점 번호 이렇게 구할 수 있음

    while p and heap[p] < heap[c]:# 부모가 있고, 부모 < 자식인 경우 자리 교환
        heap[p], heap[c] = heap[c], heap[p]
        c = p # 부모를 새로운 자식으로
        p = c // 2
```

### 힙 연산 - 삭제
- 힙에서는 루트 노드의 원소만을 삭제할 수 있음
- 루트 노드의 원소를 삭제하여 반환함
- 힙의 종류에 따라 최대값 or 최소값을 구할 수 있음

__<최대 힙에서의 삭제 연산>__

자식이 있고, 부모 < 자식이면 교환하는데 자식이 하나만 있거나 둘 다 있는 경우(두 자식 중 더 큰 자식을 찾는 작업 필요) 모두 고려\
→ deq해서 꺼낸 결과는 내림차순 정렬임
```python
def deq():
    global last
    # 루트 백업 (바로 버리는 게 아니라)
    temp = heap[1]
    heap[1] = heap[last]    # 삭제할 노드의 키(last에 있는 애)를 루트에 복사
    last -= 1               # last 마지막 노드 삭제

    p = 1                   #루트에 옮긴 값을 자식과 비교
    c = p * 2               # 왼쪽 자식
    while c <= last:        # 자식이 하나라도 있으면
        if c + 1 <= last and heap[c + 1] > heap[c]: # 오른쪽에 자식도 있고, 오른쪽 자식이 더 크면
            c += 1                              # 비교 대상을 오른쪽 자식으로 정함

        if heap[p] < heap[c]:   # 자식이 더 크면 최대힙 규칙에 어긋나므로
            heap[p], heap[c] = heap[c], heap[p] # 교환
            # 밑에 거를 또 비교해야 하니까
            p = c               # 자식이었던 애를 새로운 부모로
            c = p * 2           # 왼쪽 자식 번호를 계산
        else:                   # 부모가 더 크면
            break               # 비교 중단,

    return temp


heap = [0] * 100  # 100개 자리
last = 0          # 아직까지 아무것도 들어와있지 않은 상태

enq(2)
enq(5)
enq(7)
enq(3)
enq(4)
enq(6)

while last: # 다 꺼냈으면(last 양수)
    print(deq())
```
<br>
✏ 참고. 힙을 이용한 우선순위 큐
힙의 키를 우선순위로 활용하여 우선순위 큐를 구현할 수 있다.