## 스택(Stack)
선형 구조로 스택에 자료를 삽입하거나 스택엥서 자료를 꺼낼 수 있음
마지막에 삽입한 자료를 가장 먼저 꺼내는 후입선출 방식

- 스택을 프로그램에서 구현하기 위해서 필요한 자료구조와 연산
  - 자료구조 : 자료를 선형으로 저장할 저장소
    - 배열을 사용할 수 있다.
    - 저장소 자체를 스택이라 부르기도 한다.
    - 스택에서 마지막 삽입된 원소의 위치를 변수명 top이라 부른다. 공식적인 명칭은 stack pointer (st)

  - 연산
    - 삽입 : push
    - 삭제 : pop
    - 스택이 공백인지 아닌지 확인 : isEmpty _함수로 만들 수도 있고, 코드 안에 풀어서 적을 수도 있음
    - 스택의 top에 있는 item(원소)를 반환하는 연산 : peek

#### 스택의 구현
- 스택의 삽입/삭제 과정
  - 공백 스택이 스택 밑 지하에 있고 push(A) -> top ++ 하고 A가 들어감

- 스택의 push 알고리즘
  - 리스트의 append, pop은 시간이 좀 걸리는 편 -> 크기가 정해진 배열, stack pointer 정의하고 사용하는 걸 추천

- pop 알고리즘

#### 스택 구현 고려 사항
1차원 배열을 사용하여 구현할 경우 구현이 용이하단 장점, 스택의 크기를 변경하기가 어렵다는 단점 존재
-> 저장소를 동적으로 할당하여 스택을 구현하는 방법! c.f. 연결리스트?

- 스택의 응용 1 : 괄호 검사
- 앞에 있던 애랑 맞춰 봐야하는데? 스택 사용 가능
- '(' 만나면 push, ')' 만나면 pop하여 비교
- 개요 : 문자열에 있는 괄호를 차례대로 조사하면서 ( 만나면 스택에 push, ) 만나면 스택에서 top 괄호를 삭제한 후 오른쪽 괄호와 짝이 마는지를 검사한다.


- 스택의 응용 2 : fuction call
- 프로그램에서의 함수 호출과 복귀에 따른 수행 순서를 관리
- 가장 마지막에 호출된 함수가 가장 먼저 실행을 완료하고 복귀
- 함수 호출이 발생하면 호출한 함수 수행에 필요한 지역변수, 매개변수 및 수행 후 복귀할 주소 등의 정보를 스택 프레임에 저장하여 시스템 스택...?


#### 재귀 호출
함수에서 실행해야 하는 작업의 특성에 따라 일반적인 호출방식보다 재귀호출방식을 사용하여 함수를 만들면 프로그램의 크기를 줄이고 간단하게 작성

- 피보나치

#### Memoization
피보나치 수를 구하는 함수를 재귀함수로 구하면 -> 엄청난 중복 호출 발생
- 메모이제이션 : 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 함. 동저 계획법의 핵심 기술.


#### DP(Dynamic Programming)
동적 계획 알고리즘 : 그리디 알고리즘과 같이 최적화 문제를 해결하는 알고리즘

테이블 만들어서 중간중간 값들을 다 저장한다?
N이 주어진다. 피보나치(N) 구할 때 이때까지는 10에 대해서 계산하고, 20에 대해서 계산하고... 이랬는데
이제는 0 <= N <= 100 에서 이거를 테스트 케이스마다 다 돌리는 게 아니라, 테이블을 만들고 돌려가면서 씀

if 계속 꺼낼 필요 없이, 최종값만 남기면 돼서 전체 테이블을 모두 남겨둘 필요 없이 계산에 필요한 최소한의 요소들만 남겨놔도 된다면? a, b = b, a + b

```
a = 0
b = 1
n = 20
for _ in range(n - 1):
    a, b = b, a+b
print(b)
```
tip : DP로 풀면 유용한 문제 유형들을 그 정도를 풀고나면 대충 DP가지고 푸는 문제인지 감이 온다!

- DP의 구현 방식
  - recursive 방식 : fib1()
  - iterative 방식 : fib2()
  - 함수 호출 깊이는 깊어지지 않는 게 좋기 때문에 memoization을 재귀적 구조에 사용하느 것보다 반복적 구조로 DP를 구현하는 것이 성능면에서 보다 효율적

#### DFS(깊이우선탐색)
시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색해 가다가 더 이상 갈 곳이 없게 되면, 가장 마지막에 만났던 갈림길 간선이 있는 정점으로 되돌아와서 다른 방향의 정점으로 탐색을 계속 반복하여 결국 모든 정점을 반복하는 순회 방법
-> 가장 마지막에 만났던 갈림길의 정점으로 되돌아가서 다시 깊이 우선 탐색을 반복해야 하므로 후입선출 구조의 Stack 사용

- DFS 알고리즘
- 1) 시작 정점 V를 결정하여 방문한다.
- 2) 정점 V에 인접한 정점 중에서
  - (1) 방문하지 않은 정점 W가 있으면, 정점 V를 스택에 push하고 정점 w를 방문한다.
  - (2) 방문하지 않은 정점이 없으면, 탐색의 방향을 바꾸기 위해서 스택을 pop하여 받은 마지막 방문 정점을 v로 항 다시 2)를 반복함
- 3) 스택이 공백이 될 때까지 2)를 반복

초기상태 : 배열 visited를 False로 초기화하고, 공백 스택을 생성
정점 A에 방문하지 않은 정점 B,C가 있으므로 A를 스택에 push, B,C 중에서 오름차순에 따라 B를 선택하여 탐색을 계속함 -> B가 v가 됨, 
A도 인접이긴 한데 이미 방문한 곳이니 탈락함, D,E 중 선택 -> D 선택...
더 이상 방문하지 않은 인접이 없어서 w로 삼을 만한 애가 없으면 뒷걸음질

+ 인접 관계는 어떻게 표시? -> 리스트 사용

c.f. 이해 못함 : stack에 0에서 인접한 1,2를 둘다 넣으면 뒷걸음질 방법이 아니라 둘을 점프해서 가는 방법도 할 수 있음?