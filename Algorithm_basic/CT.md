# Computational Thinking
### 0.서론 - 프로그래밍과 논리/수학
- 조건명제
  - p → q
  - q가 T면 T
  - p가 F면 T
- 쌍방조건명제
  - p ↔ q
  - p와 q 둘다 T, 둘다 F일 때만 T

- 조건명제의 역, 이, 대우
  - 대우 : ¬q → ¬p

🧷 증명
- 정확한 명제식으로 표현할 수 있는 것
- 수학적 귀납법
  
### 1. 논리와 증명
- 문제 3 : 다음 명제의 쌍 들에서 대해서 두 명제가 동등한지 진리표를 이용해서 확인
- 문제 4 : 명제식의 변형을 통하여 다음 명제를 간소화
- 문제 5 : ∃x ϵ R, x^2 < x 참인지 확인
- 문제 6 : (직접 증명) n이 짝수이면  3n + 5는 홀수임을 증명하라
- 문제 8 : m이 짝수이고 n이 홀수이면 2, + 3n은 홀수임을 증명하라
  - 2k, 2l + 1을 m, n에 대입하여 풂

- 문제 9 : (대우를 증명) 자연수 n에 대해, n^2 + 5가 홀수이면 n은 짝수임을 증명하라
  - 대우로 생각해서 증명!
- 문제 10 : n^2이 짝수이면 n은 짝수임을 증명하라

### 2. 수와 표현
- 컴퓨터는 0/1을 표현할 수 있는 비트들을 모아 수를 표현
- k개의 비트를 사용하면 최대 2^k-1가지의 값까지 표현 가능
  - ex. 4비트 -> 0 ~ 15, -8 ~ +7... 등 어떻게 약속을 정하냐에 따라 비트로 표현할 수 있는 숫자의 범위는 달라질 수 있음
- 10진수로 k자리를 쓰면 0부터 10^k-1까지 표현이 가능한 것과 동일한 과정이라 판단

Q. 어떤 값 n을 표현하기 위해서는 몇 개의 비트가 필요할까?
- 2^k - 1 >= n 이 성립해야 함 -> 즉, 2^k >= n + 1
- 따라서, k >= log(n + 1) -> 약 log n 비트가 필요

Problems
- 문제 1 : 2진수 표현에서 log n 비트로 표현할 수 있는 숫자 범위는?

### 3. 집합과 조합론
🧷 A형 문제를 풀 때 종종 필요한 개념적인 부분들을 학습
- 다음 두 집합이 같다는 것을 상세히 증명해보자.
  - A가 B의 부분집합이다 :
    - A에 포함되는 임의의 원소 X를 가정
    - x=2k + 1임
  - B가 A의 부분집합이다 :
  - 위 두 가지 증명에서 집합 A == 집합 B

🧷 조합론 - 경우의 수를 따지는 문제들
사실 실제 문제를 풀 때 필요한 것은 '경우의 수'보다는 조합 자체를 만드는 과정 → 추후에 학습 예정
🧷 그럼 조합론이 필요한 이유? 
조합으로 푸는 게 맞는지, 얼마나 많은 경우가 만들어져야 하는 것인가를 따질 때 필요!

Problems

### 📌 4. 기초 수식
알고리즘의 시간 복잡도를 표현할 수 있는 다양한 수식이 존재하므로 풀이법을 익혀 두어야 알고리즘의 시간 복잡도를 계산할 수 있고, 알고리즘의 시간이 얼마나 걸릴지 예측할 수 있음

### 5. 재귀
- 재귀란 자기 자신을 호출하는 함수, 그럼 끝날 수 있는가?
- 함수는 입력이 있으며, 자기 자신의 입력과 동일한 입력으로 자기 자신을 호출하면 당연히 끝나지 않음
- 하지만, 다른 입력으로 호출하면 끝날 수 있음

```python
# sum의 호출 반복 -> 
# 종료(이후 sum 호출로 만들어진 메모리 영역 날라감) 
# -> 리턴 반복
int sum(int x)
{
  if (x <= 0) return 0;
  return x + sum(x - 1);
}
```

### 6. 동적 프로그래밍
- 재귀 함수에서 동일한 입력의 함수 호출이 반복적으로 일어날 때, 그 결과값을 저장해두고 불러 쓰는 것 (Memoization)
- 최초 입력에서 파생되는 모든 가능한 입력에 대한 답을 모두 저장할 수 있는 메모리가 있어야 함
- 단순히 재귀에서 저장된 값을 찾아보는 것으로도 가능하지만, 결과값의 순서를 정해서 계산할 수도 있음 (Dynamic Porgramming)
- 상향식 구조 : 작은 부분 최적해를 구해놓고 더 큰 문제를 해결해나가는 방식
  - 피보나치는 1차원 배열로 푸는 문제고, 그 외의 DP는 이차원에서 값을 정하는/이 칸에 해당하는 최적해를 구하는 방법들이 문제에 따라서 나타남. 경우의 수를 다 따져보는 방식.